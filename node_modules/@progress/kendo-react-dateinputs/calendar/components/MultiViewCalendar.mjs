/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as p from "react";
import s from "prop-types";
import { provideIntlService as j, provideLocalizationService as G, registerForIntl as X, registerForLocalization as q } from "@progress/kendo-react-intl";
import { Keys as O, classNames as J, createPropsContext as Q, withIdHOC as Z, withPropsContext as ee } from "@progress/kendo-react-common";
import { isEqualDate as N, addDays as A, cloneDate as m, getDate as g, firstDayOfMonth as te, lastDayOfMonth as se } from "@progress/kendo-date-math";
import { Button as P } from "@progress/kendo-react-buttons";
import { chevronRightIcon as B, chevronLeftIcon as L } from "@progress/kendo-svg-icons";
import { Action as C } from "../models/NavigationAction.mjs";
import { CalendarViewEnum as M } from "../models/CalendarViewEnum.mjs";
import { EMPTY_SELECTIONRANGE as W } from "../models/SelectionRange.mjs";
import { Header as ie } from "./Header.mjs";
import { dateInRange as F, getToday as k, viewInRange as _, nullable as w, MIN_DATE as ae, MAX_DATE as ne, isInRange as T } from "../../utils.mjs";
import { prevView as K, messages as Y, nextView as z } from "../../messages/index.mjs";
import { BusViewService as oe } from "../services/BusViewService.mjs";
import { NavigationService as le } from "../services/NavigationService.mjs";
import { HorizontalViewList as E } from "./HorizontalViewList.mjs";
import { TodayCommand as re } from "./TodayCommand.mjs";
const S = (r = v.defaultProps.min, i = v.defaultProps.max, a) => a instanceof Date && !Array.isArray(a) && T(g(a), r, i) ? g(a) : null, U = (r = v.defaultProps.min, i = v.defaultProps.max, a) => Array.isArray(a) ? a.filter((c) => T(c, r, i)).map((c) => g(c)) : null, $ = (r) => typeof r == "object" && !(r instanceof Date) && r !== null && !Array.isArray(r) ? r : W, H = (r, i, a) => r || i && i[0] || a && a.start, he = (r, i) => r.start === null && i === null ? "start" : r.end === null ? "end" : "start", d = class d extends p.Component {
  constructor(i) {
    super(i), this.dates = [], this.selectedDate = null, this.selectedMultiple = null, this.selectedRange = W, this._focusedDate = /* @__PURE__ */ new Date(), this.cellUID = this.props.id + "-cell-uid", this.activeRangeEnd = "start", this._element = null, this.intl = null, this.localization = null, this.service = null, this.calendarViewList = null, this.isActive = !1, this.calculateFocusFromValue = !0, this.focus = () => {
      this._element && this._element.focus();
    }, this.clampRange = (e) => ({ start: e, end: null }), this.rangeWithFocused = (e, t) => ({
      start: e.start,
      end: e.end === null && e.start !== null && this.isActive ? t : e.end
    }), this.generateRange = (e, t) => {
      const { end: l, start: o } = t, h = t.start !== null && e.getTime() <= t.start.getTime();
      return !this.props.allowReverse && h ? { start: e, end: this.selectedRange.start } : this.activeRange !== "end" ? { start: e, end: l } : { start: o || this.selectedDate, end: e };
    }, this.canNavigate = (e) => {
      if (!this.service)
        return !1;
      const t = this.service.move(this.focusedDate, e);
      return this.min <= t && t <= this.max || this.service.isInSameView(t, this.min) || this.service.isInSameView(t, this.max);
    }, this.navigate = (e, t) => {
      this.calculateFocusFromValue = !1;
      const l = this.move(e, t);
      this.setState({ navigateDate: l, focusedDate: l });
    }, this.move = (e, t) => this.clampDate(this.service.move(t, e)), this.clampDate = (e) => F(e, this.min, this.max), this.shouldAutoCorrect = (e, t) => {
      const { end: l, start: o } = t;
      return this.activeRange !== "end" ? l !== null && e > l : o !== null && e < o;
    }, this.handleCellEnter = (e) => {
      this.props.mode === "range" && (this.calculateFocusFromValue = !1, this.setState({
        focusedDate: e
      }));
    }, this.handleMouseDown = (e) => {
      e.preventDefault();
    }, this.handleClick = (e) => {
      this._element && this._element.focus({ preventScroll: !0 });
    }, this.handleFocus = (e) => {
      if (this.isActive = !0, !this.calendarViewList)
        return;
      this.calendarViewList.focusActiveDate();
      const { onFocus: t } = this.props;
      t && t.call(void 0, e);
    }, this.handleBlur = (e) => {
      if (this.isActive = !1, !this.calendarViewList)
        return;
      this.calendarViewList.blurActiveDate();
      const { onBlur: t } = this.props;
      t && t.call(void 0, e);
    }, this.handleTodayClick = (e) => {
      this.todayIsInRange && this.handleDateChange(e);
    }, this.handlePrevButtonClick = () => {
      const e = C.PrevView;
      if (this.state.activeView > 0 && this.focusedDate.getFullYear() > this.dates[0].getFullYear())
        this.navigate(e, this.move(e, this.focusedDate));
      else {
        const t = this.isInMonth(this.focusedDate, this.dates[1]) ? this.move(e, this.focusedDate) : this.focusedDate;
        this.navigate(e, t);
      }
    }, this.handleNextButtonClick = () => {
      this.navigate(C.NextView, this.focusedDate);
    }, this.handleKeyDown = (e) => {
      const { keyCode: l, ctrlKey: o, metaKey: h } = e;
      if (l === 84) {
        const n = k();
        this.calculateFocusFromValue = !1, this.setState({ focusedDate: n, navigateDate: n });
      }
      if ((o || h) && (l === O.left && this.handlePrevButtonClick(), l === O.right && this.handleNextButtonClick()), l === O.enter) {
        const n = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          value: this.focusedDate,
          target: this
        };
        this.handleDateChange(n);
      } else {
        const n = F(
          this.navigation.move(
            this.focusedDate,
            this.navigation.action(e),
            this.state.activeView,
            this.service,
            e
          ),
          this.min,
          this.max
        );
        if (N(this.focusedDate, n))
          return;
        this.dates && this.service && !this.service.isInArray(n, this.dates) && this.setState({ navigateDate: n }), this.calculateFocusFromValue = !1, this.setState({ focusedDate: n });
      }
      e.preventDefault();
    }, this.handleViewChange = ({ view: e }) => {
      this.calculateFocusFromValue = !1, this.setState((t) => ({ activeView: e, navigateDate: t.focusedDate }));
    }, this.handleWeekSelection = (e, t, l) => {
      if (this.props.mode === "single")
        return;
      const o = 0, h = 6, n = t === o ? e : A(e, -t), u = t === h ? e : A(e, h - t);
      let f = null;
      if (this.props.mode === "multiple") {
        f = [];
        for (let y = o; y <= h; y++)
          f.push(A(n, y));
        this.setState({ value: f, focusedDate: e });
      }
      this.props.mode === "range" && (f = { start: n, end: u }, this.setState({ value: f, focusedDate: e }));
      const { onChange: x } = this.props;
      if (x) {
        const y = {
          syntheticEvent: l,
          nativeEvent: l.nativeEvent,
          value: f,
          target: this
        };
        x.call(void 0, y);
      }
    }, this.handleDateChange = (e) => {
      const t = m(e.value), l = this.bus.canMoveDown(this.state.activeView);
      if (this.props.disabled)
        return;
      if (l)
        if (e.isTodayClick)
          this.bus.moveToBottom(this.state.activeView);
        else {
          this.bus.moveDown(this.state.activeView, e.syntheticEvent), this.setState({ focusedDate: t, navigateDate: t });
          return;
        }
      this.calculateFocusFromValue = !0;
      let o;
      switch (this.props.mode) {
        case "single":
          o = m(e.value);
          break;
        case "multiple":
          if (Array.isArray(this.selectedMultiple)) {
            const n = this.selectedMultiple.slice();
            let u = -1;
            n.forEach((f, x) => {
              N(f, e.value) && (u = x);
            }), u !== -1 ? n.splice(u, 1) : n.push(m(e.value)), o = n.slice();
          } else
            this.selectedDate ? o = [m(this.selectedDate), m(e.value)] : o = [m(e.value)];
          break;
        case "range": {
          o = this.selectedRange.start !== null && this.selectedRange.end !== null && this.activeRange === "start" ? this.clampRange(e.value) : this.generateRange(e.value, this.selectedRange), this.activeRangeEnd = this.activeRange !== "end" ? "end" : "start";
          break;
        }
        default:
          o = m(e.value);
          break;
      }
      this.valueDuringOnChange = o, e.isTodayClick && this.setState({ navigateDate: t }), this.setState({ value: o, focusedDate: t }), this.valueDuringOnChange = o;
      const { onChange: h } = this.props;
      if (h) {
        const n = {
          syntheticEvent: e.syntheticEvent,
          nativeEvent: e.nativeEvent,
          value: o,
          target: this
        };
        h.call(void 0, n);
      }
      this.valueDuringOnChange = void 0;
    };
    const a = i.value !== void 0 ? i.value : i.defaultValue || d.defaultProps.defaultValue, c = S(this.min, this.max, a), D = U(this.min, this.max, a), R = $(a), I = H(c, D, R), V = _(
      M[i.defaultActiveView],
      this.bottomView,
      this.topView
    ), b = F(
      i.focusedDate || I || k(),
      this.min,
      this.max
    );
    this.state = {
      value: a,
      activeView: V,
      focusedDate: b,
      navigateDate: b
    }, this.activeRangeEnd = he(R, c), this.bus = new oe(this.handleViewChange), this.navigation = new le(this.bus), this.calculateFocusFromValue = !1, this.lastView = V, this.lastViewsCount = this.props.views || E.defaultProps.views;
  }
  get wrapperID() {
    return this.props.id + "-wrapper-id";
  }
  get isRtl() {
    return this.props.dir === "rtl";
  }
  /**
   * Gets the wrapping element of the MultiViewCalendar component.
   */
  get element() {
    return this._element;
  }
  /**
   * Gets the value of the MultiViewCalendar.
   */
  get value() {
    return this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value;
  }
  /**
   * Gets the current focused date of the MultiViewCalendar.
   */
  get focusedDate() {
    return m(this._focusedDate);
  }
  get min() {
    return g(this.props.min !== void 0 ? this.props.min : d.defaultProps.min);
  }
  get max() {
    return g(this.props.max !== void 0 ? this.props.max : d.defaultProps.max);
  }
  get bottomView() {
    return M[this.props.bottomView !== void 0 ? this.props.bottomView : d.defaultProps.bottomView];
  }
  get topView() {
    return M[this.props.topView !== void 0 ? this.props.topView : d.defaultProps.topView];
  }
  get activeRange() {
    return this.props.activeRangeEnd !== void 0 ? this.props.activeRangeEnd : this.activeRangeEnd;
  }
  get todayIsInRange() {
    return T(k(), g(this.min), g(this.max));
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.calculateFocusFromValue = !0;
  }
  /**
   * @hidden
   */
  componentDidUpdate() {
    this.calendarViewList && (this.isActive ? this.calendarViewList.focusActiveDate : this.calendarViewList.blurActiveDate)();
    const i = S(this.min, this.max, this.value);
    this.calculateFocusFromValue = !!(this.selectedDate && i && this.selectedDate.getTime() && i.getTime()), this.lastView = this.state.activeView, this.lastViewsCount = this.props.views || E.defaultProps.views;
  }
  /**
   * @hidden
   */
  render() {
    this.props._ref && this.props._ref(this), this.intl = j(this), this.localization = G(this), this.bus.configure(this.bottomView, this.topView);
    const i = _(this.state.activeView, this.bottomView, this.topView);
    this.service = this.bus.service(i, this.intl), this.selectedDate = S(this.min, this.max, this.value), this.selectedMultiple = U(this.min, this.max, this.value), this.selectedRange = $(this.value);
    const a = H(this.selectedDate, this.selectedMultiple, this.selectedRange);
    this._focusedDate = F(
      this.calculateFocusFromValue && a !== null ? a : this.state.focusedDate,
      this.min,
      this.max
    );
    const c = J(
      "k-calendar k-calendar-range k-calendar-md",
      {
        "k-disabled": this.props.disabled
      },
      this.props.className
    ), D = this.rangeWithFocused(this.selectedRange, this.focusedDate), R = this.localization.toLanguageString(K, Y[K]), I = this.localization.toLanguageString(z, Y[z]), V = !this.canNavigate(C.PrevView), b = !this.canNavigate(C.NextView), e = { "aria-disabled": V }, t = { "aria-disabled": b }, l = this.lastView !== i, o = this.dates && this.isInMonth(this.state.navigateDate, this.dates[0]), h = this.lastViewsCount !== this.props.views;
    (!o || l || h) && (this.dates = this.service.datesList(
      this.state.navigateDate,
      this.props.views || E.defaultProps.views
    ));
    const n = m(this.dates && this.dates[0] ? this.dates[0] : k());
    return /* @__PURE__ */ p.createElement(
      "div",
      {
        ref: (u) => {
          this._element = u;
        },
        className: c,
        id: this.props.id || this.wrapperID,
        "aria-labelledby": this.props.ariaLabelledBy,
        "aria-describedby": this.props.ariaDescribedBy,
        tabIndex: this.props.disabled ? void 0 : this.props.tabIndex,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        onMouseDown: this.handleMouseDown,
        onClick: this.handleClick,
        onKeyDown: this.handleKeyDown,
        "aria-disabled": this.props.disabled,
        dir: this.props.dir
      },
      /* @__PURE__ */ p.createElement(
        ie,
        {
          key: `.kendo.calendar.header.${n.getTime()}`,
          activeView: i,
          currentDate: n,
          min: this.min,
          max: this.max,
          rangeLength: this.props.views,
          bus: this.bus,
          service: this.service,
          headerTitle: this.props.headerTitle,
          verticalView: this.props.mobileMode,
          commands: /* @__PURE__ */ p.createElement(p.Fragment, null, /* @__PURE__ */ p.createElement(
            P,
            {
              type: "button",
              className: "k-calendar-nav-prev",
              icon: this.isRtl ? "chevron-right" : "chevron-left",
              svgIcon: this.isRtl ? B : L,
              fillMode: "flat",
              title: R,
              disabled: V,
              onClick: this.handlePrevButtonClick,
              ...e
            }
          ), /* @__PURE__ */ p.createElement(
            re,
            {
              min: this.min,
              max: this.max,
              onClick: this.handleTodayClick,
              disabled: !this.todayIsInRange
            }
          ), /* @__PURE__ */ p.createElement(
            P,
            {
              type: "button",
              className: "k-calendar-nav-next",
              icon: this.isRtl ? "chevron-left" : "chevron-right",
              svgIcon: this.isRtl ? L : B,
              fillMode: "flat",
              title: I,
              disabled: b,
              onClick: this.handleNextButtonClick,
              ...t
            }
          ))
        }
      ),
      /* @__PURE__ */ p.createElement(
        E,
        {
          ref: (u) => {
            this.calendarViewList = u;
          },
          dates: this.dates,
          activeView: i,
          focusedDate: this.focusedDate,
          weekDaysFormat: this.props.weekDaysFormat,
          min: this.min,
          max: this.max,
          bus: this.bus,
          service: this.service,
          selectionRange: D,
          value: this.selectedMultiple || this.selectedDate,
          cellUID: this.cellUID,
          views: this.props.views,
          onChange: this.handleDateChange,
          onWeekSelect: this.handleWeekSelection,
          showWeekNumbers: this.props.weekNumber,
          onCellEnter: this.handleCellEnter,
          cell: this.props.cell,
          weekCell: this.props.weekCell,
          headerTitle: this.props.headerTitle,
          verticalView: this.props.mobileMode,
          showOtherMonthDays: this.props.showOtherMonthDays,
          allowReverse: this.props.allowReverse
        }
      )
    );
  }
  // protected isListInRange = (list: Date[]): boolean => {
  //     return this.min < list[0]
  //         && this.max > list[Math.max(0, (this.props.views || MultiViewCalendarWithoutContext.defaultProps.views) - 1)];
  // };
  isInMonth(i, a) {
    return !!a && te(a) <= i && i <= se(a);
  }
};
d.displayName = "MultiViewCalendar", d.propTypes = {
  activeRangeEnd: s.oneOf(["start", "end"]),
  allowReverse: s.bool,
  bottomView: s.oneOf(["month", "year", "decade", "century"]),
  className: s.string,
  defaultActiveView: s.oneOf(["month", "year", "decade", "century"]),
  defaultValue: s.oneOfType([
    w(s.instanceOf(Date)),
    s.arrayOf(s.instanceOf(Date)),
    s.shape({
      start: w(s.instanceOf(Date)),
      end: w(s.instanceOf(Date))
    })
  ]),
  disabled: s.bool,
  focusedDate: s.instanceOf(Date),
  id: s.string,
  weekDaysFormat: s.oneOf(["narrow", "short", "abbreviated"]),
  ariaLabelledBy: s.string,
  ariaDescribedBy: s.string,
  max: s.instanceOf(Date),
  min: s.instanceOf(Date),
  mode: s.oneOf(["single", "multiple", "range"]),
  onBlur: s.func,
  onChange: s.func,
  onFocus: s.func,
  tabIndex: s.number,
  topView: s.oneOf(["month", "year", "decade", "century"]),
  value: s.oneOfType([
    w(s.instanceOf(Date)),
    s.arrayOf(s.instanceOf(Date)),
    s.shape({
      start: w(s.instanceOf(Date).isRequired),
      end: w(s.instanceOf(Date).isRequired)
    })
  ]),
  views: (i, a, c) => {
    const D = i[a];
    return D !== void 0 && D < 1 ? new Error(
      `Invalid prop '${a}' supplied to'${c}'. The '${a}' property cannot be less than 1'`
    ) : null;
  },
  weekNumber: s.bool,
  showOtherMonthDays: s.bool,
  dir: s.string
}, d.defaultProps = {
  disabled: !1,
  min: ae,
  max: ne,
  navigation: !0,
  defaultActiveView: "month",
  defaultValue: null,
  topView: "century",
  weekDaysFormat: "short",
  tabIndex: 0,
  bottomView: "month",
  views: 2,
  allowReverse: !1,
  showOtherMonthDays: !1
};
let v = d;
const ce = Q(), de = Z(ee(ce, v));
de.displayName = "KendoReactMultiViewCalendar";
X(v);
q(v);
export {
  de as MultiViewCalendar,
  ce as MultiViewCalendarPropsContext,
  v as MultiViewCalendarWithoutContext
};
