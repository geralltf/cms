/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as n from "react";
import c from "prop-types";
import { cloneDate as f } from "@progress/kendo-date-math";
import { Keys as a, getActiveElement as x, noop as O } from "@progress/kendo-react-common";
import { provideIntlService as b, registerForIntl as S } from "@progress/kendo-react-intl";
import { Virtualization as T } from "../virtualization/Virtualization.mjs";
import { TIME_PART as p } from "./models/TimePart.mjs";
import { DayPeriodService as I } from "./services/DayPeriodService.mjs";
import { DOMService as H } from "./services/DOMService.mjs";
import { HoursService as E } from "./services/HoursService.mjs";
import { MinutesService as y } from "./services/MinutesService.mjs";
import { SecondsService as M } from "./services/SecondsService.mjs";
import { debounce as D, MAX_TIME as w, MIDNIGHT_DATE as R } from "../utils.mjs";
const k = 2, v = 0.05, C = 100, P = 0, g = 9, z = {
  [a.end]: (h, o) => h[h.length - 1],
  [a.home]: (h, o) => h[0],
  [a.up]: (h, o) => h[o - 1],
  [a.down]: (h, o) => h[o + 1]
}, m = {
  [p.dayperiod]: I,
  [p.hour]: E,
  [p.minute]: y,
  [p.second]: M
}, r = class r extends n.Component {
  constructor(o) {
    super(o), this.intl = null, this._element = null, this.service = null, this.virtualization = null, this.topOffset = 0, this.bottomOffset = 0, this.itemHeight = 0, this.listHeight = 0, this.topThreshold = 0, this.bottomThreshold = 0, this.animateToIndex = !1, this.focus = (t) => {
      Promise.resolve().then(() => {
        this.element && this.element.focus(t);
      });
    }, this.itemOffset = (t) => {
      if (!this.virtualization || !this.service)
        return -1;
      const e = this.service.selectedIndex(this.props.value), i = this.virtualization.activeIndex(), s = this.virtualization.itemOffset(i), l = Math.abs(Math.ceil(t) - s);
      if (e === i && l < k)
        return s;
      const u = e > i;
      return u && l >= this.bottomThreshold || !u && l > this.topThreshold ? this.virtualization.itemOffset(i + 1) : s;
    }, this.calculateHeights = () => {
      this.dom.didCalculate && (this.itemHeight = this.dom.itemHeight, this.listHeight = this.dom.timeListHeight, this.topOffset = (this.listHeight - this.itemHeight) / 2, this.bottomOffset = this.listHeight - this.itemHeight, this.props.mobileMode && (this.topOffset += g, this.bottomOffset += g * 2), this.topThreshold = this.itemHeight * v, this.bottomThreshold = this.itemHeight * (1 - v));
    }, this.configureServices = ({ min: t, max: e, value: i } = this.props) => {
      if (this.service) {
        const [s, l] = this.service.limitRange(t || this.min, e || this.max, i || this.props.value);
        this.service.configure(this.serviceSettings({ min: s, max: l }));
      }
    }, this.serviceSettings = (t) => {
      const e = {
        boundRange: this.props.boundRange || r.defaultProps.boundRange,
        insertUndividedMax: !1,
        min: f(this.min),
        max: f(this.max),
        part: this.props.part,
        step: this.step
      }, i = Object.assign({}, e, t);
      return i.boundRange = i.part.type !== "hour" || this.props.boundRange || r.defaultProps.boundRange, i;
    }, this.handleScrollAction = ({ target: t, animationInProgress: e }) => {
      if (!(!this.virtualization || !this.service) && t && !e) {
        this.animateToIndex = !1;
        const i = this.virtualization.itemIndex(this.itemOffset(t.scrollTop)), s = this.service.data(this.props.value)[i];
        this.handleChange(s);
      }
    }, this.handleFocus = (t) => {
      const { onFocus: e } = this.props;
      e && e.call(void 0, t);
    }, this.handleBlur = (t) => {
      const { onBlur: e } = this.props;
      e && e.call(void 0, t);
    }, this.handleMouseOver = () => {
      if (!this._element)
        return;
      const t = x(document);
      document && t !== this._element && this.props.show && this._element.focus({ preventScroll: !0 });
    }, this.handleKeyDown = (t) => {
      if (!this.service)
        return;
      const { keyCode: e } = t;
      (e === a.down || e === a.up || e === a.end || e === a.home) && t.preventDefault();
      const s = (z[t.keyCode] || O)(
        this.service.data(this.props.value),
        this.service.selectedIndex(this.props.value)
      );
      s && this.handleChange(s);
    }, this.handleChange = D((t) => {
      if (!this.service)
        return;
      const e = this.service.apply(this.props.value, t.value);
      if (this.props.value.getTime() === e.getTime())
        return;
      const { onChange: i } = this.props;
      i && i.call(void 0, e);
    }, C), this.dom = new H();
  }
  get element() {
    return this._element;
  }
  get animate() {
    return !!(this.props.smoothScroll && this.animateToIndex);
  }
  get min() {
    return this.props.min || r.defaultProps.min;
  }
  get max() {
    return this.props.max || r.defaultProps.max;
  }
  get step() {
    return this.props.step !== void 0 && this.props.step !== 0 ? Math.floor(this.props.step) : r.defaultProps.step;
  }
  /**
   * @hidden
   */
  componentDidMount() {
    Promise.resolve().then(() => {
      this._element && (this.dom.calculateHeights(this._element), this.forceUpdate());
    });
  }
  /**
   * @hidden
   */
  componentDidUpdate() {
    if (!this.virtualization || !this.service)
      return;
    const o = this.service.selectedIndex(this.props.value);
    this.virtualization[this.animate ? "animateToIndex" : "scrollToIndex"](o), this.animateToIndex = !0;
  }
  /**
   * @hidden
   */
  render() {
    if (!this.props.part.type || !m[this.props.part.type])
      return;
    this.calculateHeights(), this.intl = b(this), this.service = new m[this.props.part.type](this.intl), this.configureServices();
    const o = this.service.data(this.props.value), t = "translateY(" + this.topOffset + "px)", e = this.service.total(this.props.value), i = /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
      "ul",
      {
        style: { transform: t, msTransform: t },
        className: "k-reset"
      },
      o.map((s, l) => /* @__PURE__ */ n.createElement("li", { key: l, className: "k-item", onClick: () => {
        this.handleChange(s);
      } }, /* @__PURE__ */ n.createElement("span", null, s.text)))
    ), /* @__PURE__ */ n.createElement("div", { className: "k-scrollable-placeholder" }));
    return /* @__PURE__ */ n.createElement(
      "div",
      {
        className: "k-time-list",
        id: String(this.props.id || ""),
        tabIndex: this.props.disabled ? -1 : 0,
        ref: (s) => {
          this._element = s;
        },
        onKeyDown: this.handleKeyDown,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        onMouseOver: this.handleMouseOver
      },
      this.dom.didCalculate ? /* @__PURE__ */ n.createElement(
        T,
        {
          bottomOffset: this.bottomOffset,
          children: i,
          className: "k-time-container",
          itemHeight: this.itemHeight,
          maxScrollDifference: this.listHeight,
          onScrollAction: this.handleScrollAction,
          ref: (s) => {
            this.virtualization = s;
          },
          role: "presentation",
          skip: P,
          tabIndex: -1,
          take: e,
          topOffset: this.topOffset,
          total: e
        }
      ) : /* @__PURE__ */ n.createElement("div", { className: "k-time-container k-content k-scrollable" }, i)
    );
  }
};
r.propTypes = {
  id: c.number,
  max: c.instanceOf(Date),
  min: c.instanceOf(Date),
  part: function(o, t, e) {
    const i = o[t];
    if (!i || !m[i.type])
      throw new Error(`
                    Invalid prop '${t}' supplied to ${e}.
                    Supported part types are hour|minute|second|dayperiod.
                `);
    return null;
  },
  step: function(o, t, e) {
    const i = o[t];
    if (i !== void 0 && i <= 0)
      throw new Error(`
                    Invalid prop '${t}' supplied to ${e}.
                    ${t} cannot be less than 1.
                `);
    return null;
  },
  value: c.instanceOf(Date),
  smoothScroll: c.bool,
  show: c.bool
}, r.defaultProps = {
  boundRange: !1,
  max: w,
  min: R,
  step: 1,
  smoothScroll: !0
};
let d = r;
S(d);
export {
  d as TimeList
};
