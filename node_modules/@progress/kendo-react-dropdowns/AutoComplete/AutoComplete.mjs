/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as I from "react";
import c from "prop-types";
import M from "../common/SearchBar.mjs";
import T from "../common/ListContainer.mjs";
import N from "../common/List.mjs";
import S from "../common/DropDownBase.mjs";
import L from "../common/GroupStickyHeader.mjs";
import { getItemValue as b, areSame as C, getFocusedItem as F, itemIndexStartsWith as H } from "../common/utils.mjs";
import { Keys as m, validatePackage as R, classNames as k, IconWrap as q, createPropsContext as K, withIdHOC as z, withPropsContext as G, kendoThemeMaps as $ } from "@progress/kendo-react-common";
import { FloatingLabel as A } from "@progress/kendo-react-labels";
import { packageMetadata as U } from "../package-metadata.mjs";
import j from "../common/ClearButton.mjs";
import O from "../common/withCustomComponent.mjs";
const J = "Please enter a valid value!", { sizeMap: P, roundedMap: Q } = $, y = class y extends I.Component {
  constructor(a) {
    super(a), this.state = {}, this.base = new S(this), this._element = null, this._suggested = "", this._input = null, this._isScrolling = !1, this.itemHeight = 0, this.focus = () => {
      this._input && this._input.focus();
    }, this.handleItemSelect = (t, e) => {
      const { data: s = [] } = this.props, n = b(s[t], this.props.textField);
      this.triggerOnChange(n, e);
    }, this.itemFocus = (t, e) => {
      const { data: s = [], textField: n } = this.props, i = s[t];
      C(this.state.focusedItem, i, n) || (e.data.focusedItem = i);
    }, this.togglePopup = (t) => {
      this.base.togglePopup(t);
    }, this.setValidity = () => {
      this._input && this._input.setCustomValidity && this._input.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || J
      );
    }, this.onScroll = (t) => {
      this._isScrolling = !0;
      const { list: e } = this.base, { groupField: s } = this.props;
      let { data: n = [] } = this.props;
      if (!s || !n.length)
        return;
      const i = this.itemHeight || (e ? e.children[0].offsetHeight : 0), l = t.target.scrollTop;
      s && (n = this.base.getGroupedDataModernMode(n, s));
      let o = n[0][s];
      for (let d = 1; d < n.length && !(i * d > l); d++)
        n[d] && n[d][s] && (o = n[d][s]);
      o !== this.state.group && this.setState({
        group: o
      });
    }, this.handleItemClick = (t, e) => {
      this.base.handleItemClick(t, e), this._valueDuringOnChange = void 0;
    }, this.onChangeHandler = (t) => {
      const s = this.base.initState(), n = t.currentTarget, i = n.value, r = n.selectionEnd === i.length;
      s.syntheticEvent = t;
      const l = this._suggested, o = this.value, d = o && o.substring(0, o.length - l.length), f = d && d === i, h = d && d.length > i.length, { suggest: g } = this.props, p = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
      if (g !== void 0 && g !== !1) {
        f || h || !r ? this._suggested = "" : this.suggestValue(i);
        const u = i + this._suggested, v = { userInput: i, value: this._suggested };
        this.triggerOnChange(u, s, { suggestion: v });
      } else
        this._suggested = "", this.triggerOnChange(i, s);
      (!p && i || p && !i) && this.togglePopup(s), s.data.focusedItem = void 0, this.applyState(s), this.setState({ group: void 0 });
    }, this.clearButtonClick = (t) => {
      const s = this.base.initState(), n = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
      s.syntheticEvent = t;
      const i = "";
      this._suggested = "", this.triggerOnChange(i, s), this.state.focusedItem !== void 0 && (s.data.focusedItem = void 0), n && this.togglePopup(s), this.applyState(s);
    }, this.onInputKeyDown = (t) => {
      const { data: e = [], skipDisabledItems: s, groupField: n, textField: i } = this.props;
      this._isScrolling && (this._isScrolling = !1);
      const r = this.focusedIndex(), l = e[r], o = t.keyCode, d = t.altKey, f = this.props.opened !== void 0 ? this.props.opened : this.state.opened, h = this.base.initState();
      h.syntheticEvent = t;
      const g = () => {
        f && t.preventDefault();
      };
      if (d && o === m.down)
        this.setState({
          opened: !0
        });
      else if (d && o === m.up)
        this.setState({
          opened: !1
        });
      else if (f && o === m.pageUp)
        g(), this.base.scrollPopupByPageSize(-1);
      else if (f && o === m.pageDown)
        g(), this.base.scrollPopupByPageSize(1);
      else if (f && (o === m.enter || o === m.esc))
        g(), s === !1 && l && l.disabled ? (f && this.togglePopup(h), this.applyState(h)) : this.applyInputValue(t.currentTarget.value, h, t.keyCode);
      else if (!f && o === m.esc) {
        const p = "";
        this._suggested = "", this.triggerOnChange(p, h), this.state.focusedItem !== void 0 && (h.data.focusedItem = void 0), this.applyState(h);
      } else if (o === m.up || o === m.down) {
        if (n !== "" && i)
          if (!this.props.skipDisabledItems && f)
            this.onNavigate(h, o);
          else {
            let p = 0;
            if (o === m.down || o === m.right) {
              const u = e.slice(r + 1).find((v) => !v.disabled && v[i]);
              p = u && e.findIndex((v) => v[i] === u[i]);
            } else if (o === m.up || o === m.left) {
              let u;
              if (r === -1)
                u = e, p = e.findIndex((v) => !v.disabled && v[i]);
              else {
                u = e.slice(0, r);
                let v = u.pop();
                for (; v && v.disabled; )
                  v = u.pop();
                p = v && e.findIndex((x) => x[i] === v[i]);
              }
            }
            if (p !== void 0) {
              const u = p - r;
              this.onNavigate(h, o, u);
            } else
              p === void 0 && e.findIndex((u) => u[i]) === e.length - 1 && this.onNavigate(h, o);
          }
        else if (!this.props.skipDisabledItems && f)
          this.onNavigate(h, o);
        else {
          let p = null;
          if (o === m.down || o === m.right)
            p = e.slice(r + 1).find((u) => !u.disabled);
          else if (o === m.up || o === m.left) {
            const u = e.slice(0, r);
            for (p = u.pop(); p && p.disabled; )
              p = u.pop();
          }
          if (p) {
            const u = p.id - r - 1;
            this.onNavigate(h, o, u);
          } else
            this.onNavigate(h, o);
        }
        this.applyState(h), g();
      }
    }, this.handleBlur = (t) => {
      if (this.state.focused) {
        const e = this.base.initState();
        e.data.focused = !1, e.events.push({ type: "onBlur" }), e.syntheticEvent = t, this.applyInputValue(t.currentTarget.value, e);
      }
    }, R(U);
  }
  get _inputId() {
    return this.props.id + "-accessibility-id";
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  /**
   * The value of the AutoComplete.
   */
  get value() {
    return this._valueDuringOnChange !== void 0 ? this._valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value !== void 0 ? this.state.value : this.props.defaultValue !== void 0 ? this.props.defaultValue : "";
  }
  /**
   * Gets the `name` property of the AutoComplete.
   */
  get name() {
    return this.props.name;
  }
  /**
   * Represents the validity state into which the AutoComplete is set.
   */
  get validity() {
    const a = this.props.validationMessage !== void 0, t = !this.required || this.value !== "", e = this.props.valid !== void 0 ? this.props.valid : t;
    return {
      customError: a,
      valid: e,
      valueMissing: this.value === null
    };
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : y.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : y.defaultProps.required;
  }
  /**
   * @hidden
   */
  componentDidUpdate(a, t) {
    var g;
    const { groupField: e = "", data: s = [] } = this.props, { data: n = [] } = a, i = this.focusedIndex(), r = s[i], l = n !== s, o = r !== void 0 && t.focusedItem !== r, d = this.props.opened !== void 0 ? this.props.opened : this.state.opened, f = a.opened !== void 0 ? a.opened : t.opened, h = !f && d;
    if (e === "")
      (d && (o || l) || h) && this.base.scrollToItem(i);
    else if (!this._isScrolling) {
      const p = (g = this.base.getGroupedDataModernMode(s, e)) == null ? void 0 : g.indexOf(r);
      h && (s && s.length !== 0 && this.base.resetGroupStickyHeader(s[0][e], this), this.base.scrollToItem(p)), d && f && o && this.base.scrollToItem(p);
    }
    this.setValidity();
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.base.didMount(), this.setValidity();
  }
  /**
   * @hidden
   */
  render() {
    const { dir: a, disabled: t, label: e, className: s, style: n, loading: i, suggest: r, size: l, rounded: o, fillMode: d } = this.props, f = !this.validityStyles || this.validity.valid, h = this.base, g = this.value, p = this.props.clearButton !== !1 && !i && !!g, u = this.props.id || this._inputId, v = this.state.focused;
    typeof r == "string" && (this._suggested = r);
    const [x, B] = O(this.props.prefix || I.Fragment), [V, E] = O(this.props.suffix || I.Fragment), D = /* @__PURE__ */ I.createElement(
      "span",
      {
        className: k(
          "k-autocomplete k-input",
          s,
          {
            [`k-input-${P[l] || l}`]: l,
            [`k-rounded-${Q[o] || o}`]: o,
            [`k-input-${d}`]: d,
            "k-invalid": !f,
            "k-focus": v && !t,
            "k-loading": i,
            "k-required": this.required,
            "k-disabled": t
          }
        ),
        ref: (_) => {
          this._element = _, h.wrapper = _;
        },
        style: e ? { ...n, width: void 0 } : n,
        dir: a
      },
      this.props.prefix && /* @__PURE__ */ I.createElement(x, { ...B }),
      this.renderSearchBar(g || "", u),
      i && /* @__PURE__ */ I.createElement(q, { className: "k-input-loading-icon", name: "loading" }),
      p && !i && /* @__PURE__ */ I.createElement(j, { onClick: this.clearButtonClick, key: "clearbutton" }),
      this.props.suffix && /* @__PURE__ */ I.createElement(V, { ...E }),
      this.renderListContainer()
    );
    return e ? /* @__PURE__ */ I.createElement(
      A,
      {
        label: e,
        editorId: u,
        editorValue: g,
        editorValid: f,
        editorDisabled: t,
        style: { width: n ? n.width : void 0 },
        children: D
      }
    ) : D;
  }
  /**
   * @hidden
   */
  onNavigate(a, t, e) {
    const s = this.value, { data: n = [], textField: i, focusedItemIndex: r } = this.props, l = this.state.focusedItem !== void 0 ? n.findIndex((d) => C(d, this.state.focusedItem, i)) : r ? r(n, s, i) : n.indexOf(F(n, s, i)), o = this.base.navigation.navigate({
      keyCode: t,
      current: l,
      max: n.length - 1,
      min: 0,
      skipItems: e || void 0
    });
    o !== void 0 && this.itemFocus(o, a), this.applyState(a);
  }
  /**
   * @hidden
   */
  applyInputValue(a, t, e) {
    const s = this.props.opened !== void 0 ? this.props.opened : this.state.opened, { data: n = [], textField: i } = this.props, r = this.focusedIndex(), l = n[r];
    if (this._suggested = "", s && e === m.enter && l && !l.disabled) {
      const o = b(n[this.focusedIndex(a)], i);
      this.triggerOnChange(o, t);
    }
    s && this.togglePopup(t), this.applyState(t);
  }
  renderSearchBar(a, t) {
    const e = this.base, { placeholder: s, tabIndex: n, disabled: i, readonly: r } = this.props, { focused: l } = this.state, o = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
    return /* @__PURE__ */ I.createElement(
      M,
      {
        id: t,
        placeholder: s,
        tabIndex: n,
        accessKey: this.props.accessKey,
        value: a,
        suggestedText: this._suggested,
        focused: l,
        name: this.props.name,
        ref: (d) => this._input = d && d.input,
        onKeyDown: this.onInputKeyDown,
        onChange: this.onChangeHandler,
        onFocus: e.handleFocus,
        onBlur: this.handleBlur,
        disabled: i,
        readOnly: r,
        expanded: o,
        owns: e.listBoxId,
        activedescendant: "option-" + e.guid + "-" + this.focusedIndex(),
        role: "combobox",
        ariaLabelledBy: this.props.ariaLabelledBy,
        ariaDescribedBy: this.props.ariaDescribedBy,
        ariaRequired: this.required,
        render: this.props.valueRender
      }
    );
  }
  renderListContainer() {
    const a = this.base, {
      dir: t,
      header: e,
      footer: s,
      data: n = [],
      size: i,
      groupField: r,
      list: l,
      groupStickyHeaderItemRender: o
    } = this.props, d = a.getPopupSettings(), f = this.props.opened !== void 0 ? this.props.opened : this.state.opened, h = d.width !== void 0 ? d.width : a.popupWidth;
    let { group: g } = this.state;
    return g === void 0 && r !== void 0 && (g = b(n[0], r)), /* @__PURE__ */ I.createElement(
      T,
      {
        width: h,
        popupSettings: {
          ...d,
          anchor: d.anchor || this.element,
          show: f,
          popupClass: k(
            d.popupClass,
            "k-list-container",
            "k-autocomplete-popup"
          )
        },
        dir: t !== void 0 ? t : this.base.dirCalculated,
        itemsCount: [n.length]
      },
      e && /* @__PURE__ */ I.createElement("div", { className: "k-list-header" }, e),
      /* @__PURE__ */ I.createElement(
        "div",
        {
          className: k(
            "k-list",
            {
              [`k-list-${P[i] || i}`]: i
            }
          )
        },
        !l && g && n.length !== 0 && /* @__PURE__ */ I.createElement(L, { group: g, groupMode: "modern", render: o }),
        this.renderList()
      ),
      s && /* @__PURE__ */ I.createElement("div", { className: "k-list-footer" }, s)
    );
  }
  renderList() {
    const a = this.base, t = a.getPopupSettings(), {
      textField: e,
      data: s = [],
      listNoDataRender: n,
      itemRender: i,
      groupHeaderItemRender: r
    } = this.props, l = this.value, o = this.props.opened !== void 0 ? this.props.opened : this.state.opened;
    return /* @__PURE__ */ I.createElement(
      N,
      {
        id: a.listBoxId,
        show: o,
        data: s.slice(),
        focusedIndex: this.focusedIndex(),
        value: l,
        textField: e,
        valueField: e,
        highlightSelected: !1,
        optionsGuid: a.guid,
        groupField: this.props.groupField,
        groupMode: "modern",
        listRef: (d) => a.list = d,
        wrapperStyle: { maxHeight: t.height },
        wrapperCssClass: "k-list-content",
        onClick: this.handleItemClick,
        itemRender: i,
        groupHeaderItemRender: r,
        noDataRender: n,
        onMouseDown: (d) => d.preventDefault(),
        onScroll: this.onScroll
      }
    );
  }
  triggerOnChange(a, t, e) {
    this.value === a && !e || (t.data.value = a, this._valueDuringOnChange = a, t.events.push({ type: "onChange", ...e || {} }));
  }
  applyState(a) {
    this.base.applyState(a), this._valueDuringOnChange = void 0;
  }
  suggestValue(a) {
    if (this._suggested = "", a) {
      const { data: t = [], textField: e } = this.props, s = t[H(t, a, e)];
      if (s) {
        const n = b(s, e);
        a.toLowerCase() !== n.toLowerCase() && (this._suggested = n.substring(a.length));
      }
    }
  }
  focusedIndex(a) {
    const { data: t = [], textField: e, focusedItemIndex: s, skipDisabledItems: n } = this.props, i = a !== void 0 ? a : this.value;
    if (this.state.focusedItem !== void 0)
      return t.findIndex((r) => C(r, this.state.focusedItem, e));
    if (s)
      return s(t, i, e);
    {
      const r = t.indexOf(F(t, i, e));
      return n && e && r === -1 ? t.findIndex((l) => !l.disabled && l[e]) : Math.max(0, r);
    }
  }
};
y.displayName = "AutoComplete", y.propTypes = {
  ...S.basicPropTypes,
  size: c.oneOf([null, "small", "medium", "large"]),
  rounded: c.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: c.oneOf([null, "solid", "flat", "outline"]),
  groupField: c.string,
  suggest: c.oneOfType([c.bool, c.string]),
  placeholder: c.string,
  value: c.string,
  defaultValue: c.string,
  validationMessage: c.string,
  required: c.bool,
  readonly: c.bool,
  clearButton: c.bool,
  valueRender: c.func,
  id: c.string,
  ariaLabelledBy: c.string,
  ariaDescribedBy: c.string,
  list: c.any,
  skipDisabledItems: c.bool
}, y.defaultProps = {
  ...S.defaultProps,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  skipDisabledItems: !0,
  prefix: void 0,
  suffix: void 0
};
let w = y;
const W = K(), X = z(G(W, w));
X.displayName = "KendoReactAutoComplete";
export {
  X as AutoComplete,
  W as AutoCompletePropsContext,
  w as AutoCompleteWithoutContext
};
