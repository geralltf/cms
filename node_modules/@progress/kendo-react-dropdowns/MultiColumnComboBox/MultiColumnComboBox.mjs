/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright © 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as e from "react";
import se from "prop-types";
import { PopupPropsContext as ue } from "@progress/kendo-react-popup";
import { MultiColumnList as ie } from "../common/MultiColumnList.mjs";
import { createPropsContext as de, usePropsContext as ce, getScrollbarWidth as pe, getter as P, classNames as G, setScrollbarWidth as me } from "@progress/kendo-react-common";
import { ComboBox as fe, ComboBoxWithoutContext as ge } from "../ComboBox/ComboBox.mjs";
import { getItemValue as he } from "../common/utils.mjs";
import T from "../common/withCustomComponent.mjs";
const Ce = (u, h) => u ? typeof u == "number" ? u + "px" : u : h, ke = de(), W = e.forwardRef((u, h) => {
  const t = ce(ke, u), C = e.useRef(null), a = e.useRef(null), x = pe(), {
    columns: n = s.columns,
    popupSettings: p = s.popupSettings,
    size: z = s.size,
    rounded: O = s.rounded,
    fillMode: $ = s.fillMode,
    className: L,
    prefix: j = void 0,
    suffix: V = void 0,
    onOpen: y,
    onClose: w,
    onFocus: E,
    onBlur: F,
    onChange: H,
    onFilterChange: N,
    onPageChange: S,
    ...A
  } = t;
  e.useImperativeHandle(C, () => ({
    element: a.current && a.current.element,
    focus() {
      a.current && a.current.focus();
    },
    get value() {
      return a.current && a.current.value;
    },
    get name() {
      return a.current && a.current.name;
    },
    props: t
  })), e.useImperativeHandle(h, () => C.current);
  const c = e.useMemo(
    () => {
      if (t.groupField !== void 0 && t.data)
        return he(t.data[0], t.groupField);
    },
    [t.data, t.groupField]
  ), [k, m] = e.useState(c), [M, R] = e.useState(!0), [D] = j ? T(t.prefix || e.Fragment) : [], [J] = V ? T(t.suffix || e.Fragment) : [], Q = e.useMemo(
    () => {
      const r = /* @__PURE__ */ e.createElement("th", { className: "k-table-th", colSpan: n.length }, k);
      return /* @__PURE__ */ e.createElement(e.Fragment, null, t.header, /* @__PURE__ */ e.createElement("div", { className: "k-table-header-wrap" }, /* @__PURE__ */ e.createElement("table", { className: "k-table", role: "presentation" }, /* @__PURE__ */ e.createElement("colgroup", null, n.map(
        (o, i) => /* @__PURE__ */ e.createElement(
          "col",
          {
            key: o.uniqueKey ? o.uniqueKey : i,
            style: { width: o.width ? o.width : s.width }
          }
        )
      )), /* @__PURE__ */ e.createElement("thead", { className: "k-table-thead" }, /* @__PURE__ */ e.createElement("tr", { className: "k-table-row" }, n.map((o, i) => /* @__PURE__ */ e.createElement("th", { className: "k-table-th", key: o.uniqueKey ? o.uniqueKey : i }, o.header || " "))), k && M && /* @__PURE__ */ e.createElement("tr", { className: "k-table-group-row" }, t.groupStickyHeaderItemRender ? t.groupStickyHeaderItemRender.call(void 0, r, {}) : r)))));
    },
    [t.header, n, k, M]
  ), U = e.useMemo(
    () => (
      // These additional 4px are coming from the child elements side borders (fixes horizontal scrollbar)
      `calc(${n.map((r) => Ce(r.width, s.width)).filter(Boolean).join(" + ")} + ${x}px + 4px)`
    ),
    [n, x]
  ), B = t.virtual ? t.virtual.skip : 0, X = e.useCallback(
    (r, o) => {
      const i = n.map((d, le) => /* @__PURE__ */ e.createElement(
        "span",
        {
          className: t.itemRender ? void 0 : "k-table-td",
          style: t.itemRender ? void 0 : { width: d.width ? d.width : s.width },
          key: d.uniqueKey ? d.uniqueKey : le
        },
        d.field ? String(P(d.field)(o.dataItem)) : ""
      ));
      let f, g, b, v, q = t.data || [];
      const I = o.index - B;
      t.groupField !== void 0 && (v = P(t.groupField), g = v(q[I]), b = v(q[I - 1]), g && b && g !== b && (f = g)), f && t.groupMode === "classic" && i.push(/* @__PURE__ */ e.createElement("div", { key: "group", className: "k-table-td k-table-group-td" }, /* @__PURE__ */ e.createElement("span", null, f)));
      const K = e.cloneElement(r, {
        ...r.props,
        className: G("k-table-row", {
          "k-table-alt-row": o.index % 2 !== 0,
          "k-focus": o.focused,
          "k-selected": o.selected,
          "k-first": !!f,
          "k-disabled": o.dataItem.disabled
        })
      }, i);
      return t.itemRender ? t.itemRender.call(void 0, K, o) : K;
    },
    [n, t.groupField, t.itemRender, t.data, B]
  ), l = e.useCallback(
    (r, o) => {
      r && r.call(void 0, {
        ...o,
        target: C.current
      });
    },
    []
  ), Y = e.useCallback((r) => (t.virtual || m(c), l(y, r)), [l, y, t.virtual, c]), Z = e.useCallback((r) => l(w, r), [w]), _ = e.useCallback((r) => l(E, r), [E]), ee = e.useCallback((r) => l(F, r), [F]), te = e.useCallback((r) => l(H, r), [H]), re = e.useCallback((r) => l(S, r), [S]), oe = e.useCallback((r) => (m(c), l(N, {
    ...r,
    mobileMode: r.target.mobileMode
  })), [N]), ae = e.useCallback(
    (r) => {
      m(r.group);
    },
    []
  );
  e.useEffect(() => {
    me();
  }), e.useEffect(() => {
    const r = t.data;
    m(c), r && r.length !== 0 ? R(!0) : R(!1);
  }, [t.data]);
  const ne = e.useCallback((r) => /* @__PURE__ */ e.createElement(ie, { ...r }), []);
  return /* @__PURE__ */ e.createElement(
    ue.Provider,
    {
      value: (r) => ({ ...r, popupClass: `k-dropdowngrid-popup ${p.popupClass}` })
    },
    /* @__PURE__ */ e.createElement(
      fe,
      {
        ...A,
        list: ne,
        popupSettings: {
          ...p,
          width: p.width || U,
          className: p.className
        },
        ref: a,
        header: Q,
        itemRender: X,
        groupHeaderItemRender: t.groupHeaderItemRender,
        size: z,
        rounded: O,
        fillMode: $,
        groupMode: t.groupMode,
        groupField: t.groupField,
        isMultiColumn: !0,
        onOpen: Y,
        onClose: Z,
        onFocus: _,
        onBlur: ee,
        onChange: te,
        onFilterChange: oe,
        onPageChange: re,
        onGroupScroll: ae,
        className: G("k-dropdowngrid", L),
        required: t.required,
        adaptive: t.adaptive,
        adaptiveFilter: t.adaptiveFilter,
        adaptiveTitle: t.adaptiveTitle,
        footer: t.footer,
        footerClassName: "k-table-footer",
        prefix: D,
        suffix: J
      }
    )
  );
}), be = {
  ...ge.propTypes,
  columns: se.any.isRequired
}, s = {
  columns: [],
  popupSettings: {},
  width: "200px",
  size: "medium",
  rounded: "medium",
  fillMode: "solid"
};
W.displayName = "KendoMultiColumnComboBox";
W.propTypes = be;
export {
  W as MultiColumnComboBox,
  ke as MultiColumnComboBoxPropsContext
};
