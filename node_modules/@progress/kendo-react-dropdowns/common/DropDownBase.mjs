/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as m from "react";
import s from "prop-types";
import { VirtualScroll as v } from "./VirtualScrollStatic.mjs";
import { Navigation as y } from "./Navigation.mjs";
import { scrollToItem as S, areSame as g } from "./utils.mjs";
const a = class a {
  constructor(n) {
    this.wrapper = null, this.list = null, this.vs = new v(), this.navigation = new y(), this.handleItemClick = (i, t) => {
      const e = this.initState();
      e.syntheticEvent = t, t.stopPropagation(), this.component.handleItemSelect(i, e), this.togglePopup(e), this.applyState(e);
    }, this.handleFocus = (i) => {
      if (!this.component.state.focused) {
        const t = this.initState();
        t.data.focused = !0, t.events.push({ type: "onFocus" }), t.syntheticEvent = i, this.applyState(t);
      }
    }, this.filterChanged = (i, t) => {
      const { textField: e, filterable: o } = this.component.props;
      o && t.events.push({
        type: "onFilterChange",
        filter: {
          field: e,
          operator: "contains",
          ignoreCase: !0,
          value: i
        }
      });
    }, this.togglePopup = (i) => {
      const t = this.component.props, e = t.opened !== void 0 ? t.opened : this.component.state.opened;
      t.opened === void 0 && (i.data.opened = !e), e ? i.events.push({ type: "onClose" }) : (i.events.push({ type: "onOpen" }), this.calculatePopupWidth());
    }, this.pageChange = (i, t) => {
      const e = this.initState();
      e.syntheticEvent = t, this.triggerOnPageChange(e, i.skip, i.take), this.applyState(e);
    }, this.scrollToVirtualItem = (i, t) => {
      const e = this.vs;
      if (i.skip === 0)
        e.reset();
      else {
        let o = e.translate;
        o === 0 && (e.calcScrollElementHeight(), o = e.itemHeight * i.skip, e.translateTo(o, !0)), t < 0 && o > 0 && (o += e.itemHeight * (i.pageSize / 4)), e.container && (e.container.scrollTop = o), this.scrollToItem(t, !0);
      }
    }, this.scrollPopupByPageSize = (i) => {
      var r, l, h, c, u, d;
      const t = this.vs, e = (l = (r = this.list) == null ? void 0 : r.parentElement) == null ? void 0 : l.scrollTop, o = t.enabled && t.itemHeight ? t.itemHeight : this.list ? this.list.children[0].offsetHeight : 0, p = (c = (h = this.list) == null ? void 0 : h.parentElement) == null ? void 0 : c.offsetHeight;
      e !== void 0 && p !== void 0 && ((d = (u = this.list) == null ? void 0 : u.parentElement) == null || d.scroll({ top: e + i * Math.floor(p / o) * o }));
    }, this.renderScrollElement = () => {
      const i = this.vs;
      return i.enabled && /* @__PURE__ */ m.createElement(
        "div",
        {
          ref: (t) => i.scrollElement = t,
          key: "scrollElementKey"
        }
      );
    }, this.resetGroupStickyHeader = (i, t) => {
      i !== t.state.group && t.setState({ ...t.state, group: i });
    }, this.listBoxId = n.props.id + "list", this.guid = n.props.id, this.component = n, this.vs.PageChange = this.pageChange;
  }
  didUpdate() {
    this.vs.listTransform && this.vs.list && (this.vs.list.style.transform = this.vs.listTransform, this.vs.listTransform = "");
  }
  didMount() {
    const n = this.component.props, i = n.popupSettings || {}, t = n.style || {}, e = i.width;
    let o = n.opened === !0;
    e === void 0 && this.calculatePopupWidth(), n.dir === void 0 && t.direction === void 0 && (this.calculateDir(), o = !0), o && this.component.forceUpdate();
  }
  calculateDir() {
    const n = this.component.element;
    n && n.ownerDocument && n.ownerDocument.defaultView && (this.dirCalculated = n.ownerDocument.defaultView.getComputedStyle(n).direction || void 0);
  }
  calculatePopupWidth() {
    this.wrapper && (this.popupWidth = this.wrapper.offsetWidth + "px");
  }
  scrollToItem(n, i, t) {
    const e = this.list || this.vs.list;
    if (!e && !t && setTimeout(() => {
      this.scrollToItem(n, i, !0);
    }, 10), n === 0 && i && this.vs.skip === 0) {
      this.vs.reset();
      return;
    }
    if (e && n >= 0) {
      const o = this.vs, p = o.container || e.parentNode, r = i !== void 0 ? i : o.enabled;
      S(p, e, n, o.translate, r);
    }
  }
  initState() {
    return {
      data: {},
      events: [],
      syntheticEvent: void 0
    };
  }
  applyState(n) {
    Object.keys(n.data).length > 0 && this.component.setState(n.data);
    const i = {
      syntheticEvent: n.syntheticEvent,
      nativeEvent: n.syntheticEvent ? n.syntheticEvent.nativeEvent : void 0,
      target: this.component,
      value: this.component.value
    };
    n.events.forEach((t) => {
      const e = t.type;
      delete t.type;
      const o = e && this.component.props[e];
      o && o.call(void 0, {
        ...i,
        ...t
      });
    });
  }
  triggerOnPageChange(n, i, t) {
    const e = this.component.props.virtual;
    if (e) {
      const o = Math.min(Math.max(0, i), Math.max(0, e.total - t));
      o !== e.skip && n.events.push({
        type: "onPageChange",
        page: { skip: o, take: t }
      });
    }
  }
  triggerPageChangeCornerItems(n, i) {
    const t = this.component.props, { data: e = [], dataItemKey: o, virtual: p } = t, r = t.opened !== void 0 ? t.opened : this.component.state.opened;
    n && p && this.vs.enabled && (p.skip > 0 && g(n, e[0], o) ? this.triggerOnPageChange(i, p.skip - 1, p.pageSize) : !r && p.skip + p.pageSize < p.total && g(n, e[e.length - 1], o) && this.triggerOnPageChange(i, p.skip + 1, p.pageSize));
  }
  getPopupSettings() {
    return Object.assign({}, a.defaultProps.popupSettings, this.component.props.popupSettings);
  }
  getAdaptiveAnimation() {
    const n = this.getPopupSettings();
    return n.animate !== void 0 ? n.animate : !0;
  }
  getGroupedDataModernMode(n, i) {
    const t = [];
    return n.forEach((e, o) => {
      n[o - 1] && e[i] !== n[o - 1][i] && t.push({ [i]: e[i] }), t.push(n[o]);
    }), t;
  }
};
a.basicPropTypes = {
  opened: s.bool,
  disabled: s.bool,
  dir: s.string,
  tabIndex: s.number,
  accessKey: s.string,
  data: s.array,
  textField: s.string,
  className: s.string,
  label: s.string,
  loading: s.bool,
  popupSettings: s.shape({
    animate: s.oneOfType([s.bool, s.shape({
      openDuration: s.number,
      closeDuration: s.number
    })]),
    popupClass: s.string,
    className: s.string,
    appendTo: s.any,
    width: s.oneOfType([s.string, s.number]),
    height: s.oneOfType([s.string, s.number])
  }),
  onOpen: s.func,
  onClose: s.func,
  onFocus: s.func,
  onBlur: s.func,
  onChange: s.func,
  itemRender: s.func,
  listNoDataRender: s.func,
  focusedItemIndex: s.func,
  header: s.node,
  footer: s.node
}, a.propTypes = {
  ...a.basicPropTypes,
  value: s.any,
  defaultValue: s.any,
  filterable: s.bool,
  filter: s.string,
  virtual: s.shape({
    pageSize: s.number.isRequired,
    skip: s.number.isRequired,
    total: s.number.isRequired
  }),
  onFilterChange: s.func,
  onPageChange: s.func
}, a.defaultProps = {
  popupSettings: {
    height: "200px"
  },
  required: !1,
  validityStyles: !0
};
let f = a;
export {
  f as default
};
