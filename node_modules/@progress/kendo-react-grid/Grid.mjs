/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as r from "react";
import o from "prop-types";
import { RowHeightService as re, dispatchEvent as Ge, canUseDOM as L, getActiveElement as Oe, memoizeOne as S, validatePackage as Ke, shouldShowValidationUI as Ve, setScrollbarWidth as ae, getter as Ue, classNames as M, kendoThemeMaps as O, WatermarkOverlay as Be } from "@progress/kendo-react-common";
import { tableKeyboardNavigationTools as k, tableKeyboardNavigation as _, getSelectionOptions as le, mapColumns as We, ClipboardService as $e, TableKeyboardNavigationContext as B, isRtl as je, tableColumnsVirtualization as qe, Pager as Je, tableKeyboardNavigationScopeAttributes as ne, TableSelection as he, tableKeyboardNavigationBodyAttributes as pe, DropClue as de, DragClue as ce, updateLeft as Xe, updateRight as Ye, KEYBOARD_NAV_DATA_ID as Qe } from "@progress/kendo-react-data-tools";
import { GridSelectionCell as Ze } from "./cells/GridSelectionCell.mjs";
import { GridHierarchyCell as et } from "./cells/GridHierarchyCell.mjs";
import { GridEditCell as tt } from "./cells/GridEditCell.mjs";
import { Header as st } from "./header/Header.mjs";
import { HeaderRow as it } from "./header/HeaderRow.mjs";
import { FilterRow as ot } from "./header/FilterRow.mjs";
import { GroupPanel as rt } from "./header/GroupPanel.mjs";
import { Footer as at } from "./footer/Footer.mjs";
import { provideLocalizationService as lt, registerForLocalization as nt } from "@progress/kendo-react-intl";
import { pagerMessagesMap as ht, gridAriaLabel as ue, messages as pt } from "./messages/index.mjs";
import { VirtualScroll as dt } from "./VirtualScroll.mjs";
import { VirtualScrollFixed as ge } from "./VirtualScrollFixed.mjs";
import { ColumnResize as ct } from "./drag/ColumnResize.mjs";
import { CommonDragLogic as ut } from "./drag/CommonDragLogic.mjs";
import { firefox as me, firefoxMaxHeight as fe, flatData as gt, readColumns as mt, sanitizeColumns as ft, getColumnWidth as W, autoGenerateColumns as vt, getNestedValue as ve, resolveCells as bt } from "./utils/index.mjs";
import { GridCell as Ct } from "./cells/GridCell.mjs";
import { GridGroupCell as be } from "./cells/GridGroupCell.mjs";
import { GridRow as Rt } from "./rows/GridRow.mjs";
import { GridHeaderSelectionCell as yt } from "./header/GridHeaderSelectionCell.mjs";
import { GridNoRecords as wt } from "./GridNoRecords.mjs";
import { operators as Ce } from "./filterCommon.mjs";
import { FooterRow as St } from "./footer/FooterRow.mjs";
import { normalize as It } from "./paging/GridPagerSettings.mjs";
import { packageMetadata as Re } from "./package-metadata.mjs";
import { GridDetailCell as kt } from "./cells/GridDetailCell.mjs";
import { GridDetailHierarchyCell as Et } from "./cells/GridDetailHierarchyCell.mjs";
import { SAFARI_REGEX as xt } from "./constants/index.mjs";
const z = class z extends r.Component {
  constructor(a) {
    super(a), this._columns = [], this._columnsMap = [[]], this._columnsMutations = 0, this._resized = !1, this._focusFirst = !1, this._shouldUpdateLeftRight = !0, this.contextStateRef = { current: void 0 }, this.navigationStateRef = { current: void 0 }, this._data = [], this._slicedData = void 0, this.wrapperScrollTop = 0, this.showLicenseWatermark = !1, this.headerRef = r.createRef(), this.headerElementRef = r.createRef(), this._element = null, this.tableElement = null, this.containerRef = r.createRef(), this.tableBodyRef = r.createRef(), this._footer = null, this.forceUpdateTimeout = void 0, this.isRtl = !1, this.headTable = null, this.observer = null, this.handleIntersection = (e) => {
      const t = { rowIndex: this.rowIndex };
      e.forEach((s) => {
        s.isIntersecting || this.setCurrentOnTop(t);
      });
    }, this.setCurrentOnTop = (e) => {
      if (!this.vs.container || this.props.scrollable === "none")
        return;
      this.observer && this.observer.disconnect();
      const { rowIndex: t } = e;
      if (this.props.scrollable === "virtual")
        this.vs.askedSkip = t, this.vs.container.scroll(0, Math.round(this.vs.askedSkip / this.vs.total * this.vs.container.scrollHeight));
      else if (this.element) {
        const s = t < 1 ? this.element.querySelector("tbody > tr:nth-child(1)") : this.element.querySelector(`tbody > tr:nth-child(${t + 1})`);
        s && this.containerRef.current && (this.containerRef.current.scrollTop = s.offsetTop);
      }
    }, this.scrollIntoView = (e) => {
      if (!this.vs.container || this.props.scrollable === "none")
        return;
      this.rowIndex = e.rowIndex;
      const { rowIndex: t } = e, s = this.element;
      if (this.observer && s) {
        this.observer.disconnect();
        const l = s.querySelector(`[absolute-row-index="${t}"]`);
        l ? this.observer.observe(l) : this.setCurrentOnTop(e);
      }
    }, this.fitColumns = (e) => {
      this.columnResize.dblClickHandler(null, e);
    }, this.getColumnsEssentialProps = (e) => JSON.stringify(e.map((t) => ({ id: t.id, field: t.field, title: t.title, children: t.children }))), this.checkMatchMediaColumnsDifferece = () => {
      const e = this.childrenToArray(this.props.children), t = k.getIdPrefix(this.navigationStateRef), s = this.filterHiddenColumns(e);
      return this.getColumnsEssentialProps(this.readColumns(s, t, this._columnsMutations)) === this.getColumnsEssentialProps(this._columns);
    }, this.onContextMenu = (e, t, s) => {
      if (this.props.onContextMenu) {
        const l = {
          target: this,
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          dataItem: t,
          field: s
        };
        this.props.onContextMenu.call(void 0, l);
      }
    }, this.getVirtualScroll = (e) => {
      const { rowHeight: t, detailRowHeight: s, detail: l, expandField: p, groupable: n } = e, d = this.isAllData(), f = t !== void 0 && t > 0, R = s !== void 0 && s > 0, E = n === !0 || typeof n == "object" && n.enabled !== !1;
      return !f || E && !d || !!(l && p) && (!R || !d) ? dt : ge;
    }, this.isAllData = () => {
      const { data: e, total: t } = this.props;
      return Array.isArray(e) ? e.length === t : e ? t === e.total : !1;
    }, this.initializeVirtualization = (e, t) => {
      if (this.reInitVirtualization(
        this.props.scrollable === "virtual",
        this.props.total,
        this.props.filter,
        this.props.group,
        this.props.sort,
        t || this.props.rowHeight === void 0 || this.props.rowHeight === 0
      ), this.vs.fixedScroll = this.props.fixedScroll || !1, this.vs.PageChange = this.pageChange, this.vs.realSkip = this.props.skip || 0, this.vs.pageSize = (this.props.take !== void 0 ? this.props.take : this.props.pageSize) || 0, this.vs.scrollableVirtual = this.props.scrollable === "virtual", this.vs.total = e, this.vs.propsSkip = (this.props.skip || 0) + (this.props.scrollable === "virtual" ? this.vs.topCacheCount + (this.vs.attendedSkip - (this.props.skip || 0)) : 0), this.props.rowHeight !== void 0 && this.props.rowHeight > 0 && !t) {
        const s = this.props.rowHeight * e;
        this.vs.containerHeight = me ? Math.min(fe, s) : s;
      } else
        this.vs.containerHeight = 1533915;
      if (this.vs.containerRef = this.containerRef, this.vs.tableBodyRef = this.tableBodyRef, this.vs.table = this.tableElement, this._slicedData = void 0, this.vs instanceof ge) {
        const { rowHeight: s = 0, detail: l, expandField: p } = this.props;
        let { detailRowHeight: n = 0 } = this.props;
        n = l && p ? n : s, this.isAllData() ? (this.vs.total = this._data.length, this._slicedData = this._data.slice(this.vs.realSkip, this.vs.realSkip + this.vs.pageSize), this.vs.rowHeightService = this.rowHeightService(this.vs, this._data.length, s, n, this._data)) : this.vs.rowHeightService = new re(e, s, n);
        const d = this.vs.rowHeightService.totalHeight();
        this.vs.containerHeight = me ? Math.min(fe, d) : d;
      }
    }, this.scrollHandler = (e) => {
      if (e.target !== e.currentTarget)
        return;
      clearTimeout(this.forceUpdateTimeout), this.vs.table = this.tableElement;
      const t = e.currentTarget.scrollLeft, s = e.currentTarget.scrollTop;
      this.props.columnVirtualization && (!this.vs.scrollableVirtual || s === this.wrapperScrollTop) && (this.forceUpdateTimeout = window.setTimeout(() => {
        this.forceUpdate();
      }, 0)), this._header && this._header.setScrollLeft(t), this._footer && this._footer.setScrollLeft(t), this.vs && s !== this.wrapperScrollTop && this.vs.scrollHandler(e), Ge(this.props.onScroll, e, this, void 0), this.wrapperScrollTop = s;
    }, this.onKeyDown = (e) => {
      if (_.onKeyDown(e, {
        contextStateRef: this.contextStateRef,
        navigationStateRef: this.navigationStateRef,
        onNavigationAction: this.onNavigationAction
      }), this.props.onKeyDown) {
        const { mode: t, cell: s } = le(this.props.selectable), l = {
          dataItems: this.getLeafDataItems(),
          mode: t,
          cell: s,
          componentId: this._gridId,
          selectedField: this.props.selectedField,
          ...this.getArguments(e)
        };
        this.props.onKeyDown.call(void 0, l);
      }
    }, this.onFocus = (e) => {
      _.onFocus(e, {
        contextStateRef: this.contextStateRef
      });
    }, this.onNavigationAction = (e) => {
      if (e.action === "moveToNextPage" && this.moveToNextPage(e.event), e.action === "moveToPrevPage" && this.moveToPrevPage(e.event), e.focusElement && e.action === "reorderToRight") {
        const t = parseInt(e.focusElement.ariaColIndex, 10) - 1;
        t < this._columns.length - 1 && this.columnReorder(t, t + 1, e.event);
      }
      if (e.focusElement && e.action === "reorderToLeft") {
        const t = parseInt(e.focusElement.ariaColIndex, 10) - 1;
        t > 0 && this.columnReorder(t, t - 1, e.event);
      }
      if (this.props.onNavigationAction) {
        const t = {
          focusElement: e.focusElement,
          ...this.getArguments(e.event)
        };
        this.props.onNavigationAction.call(void 0, t);
      }
    }, this.rowClick = (e, t) => {
      this.props.onRowClick && e.target.nodeName === "TD" && this.props.onRowClick.call(
        void 0,
        {
          dataItem: t.dataItem,
          ...this.getArguments(e)
        }
      );
    }, this.rowDblClick = (e, t) => {
      this.props.onRowDoubleClick && e.target.nodeName === "TD" && this.props.onRowDoubleClick.call(
        void 0,
        {
          dataItem: t.dataItem,
          ...this.getArguments(e)
        }
      );
    }, this.itemChange = (e) => {
      const t = this.props.onItemChange;
      if (e.field === this.props.expandField || this.props.group && e.field === void 0) {
        const s = this.props.onExpandChange;
        s && s.call(
          void 0,
          {
            ...this.getArguments(e.syntheticEvent),
            dataItem: e.dataItem,
            dataIndex: e.dataIndex,
            value: e.value
          }
        );
        return;
      }
      t && t.call(
        void 0,
        {
          ...this.getArguments(e.syntheticEvent),
          dataItem: e.dataItem,
          field: e.field,
          value: e.value
        }
      );
    }, this.onHeaderSelectionChange = (e) => {
      this.props.onHeaderSelectionChange && this.props.onHeaderSelectionChange.call(
        void 0,
        {
          field: e.field,
          nativeEvent: e.syntheticEvent && e.syntheticEvent.nativeEvent,
          syntheticEvent: e.syntheticEvent,
          target: this,
          dataItems: this.getLeafDataItems(),
          selectedField: this.props.selectedField
        }
      );
    }, this.selectionRelease = (e) => {
      if (this.props.onSelectionChange) {
        const t = this.getSlicedLeafDataItems()[e.startRowIndex], s = this.getSlicedLeafDataItems()[e.endRowIndex], l = {
          syntheticEvent: void 0,
          target: this,
          selectedField: this.props.selectedField || "",
          componentId: this._gridId,
          dataItems: this.getLeafDataItems(),
          dataItem: null,
          startDataItem: t,
          endDataItem: s,
          ...e
        };
        this.props.onSelectionChange.call(void 0, l);
      }
    }, this.pageChange = (e, t, s) => {
      this.raiseDataEvent(
        this.props.onPageChange,
        { page: e },
        { skip: e.skip, take: e.take },
        t,
        s
      );
    }, this.getTotal = () => {
      let e = this.props.total || 0;
      return Array.isArray(this.props.data) ? e = e || this.props.data.length : this.props.data && (e = e || this.props.data.total), e;
    }, this.moveToNextPage = (e) => {
      const t = this.props.take || 0, s = (this.props.skip || 0) + t, l = this.getTotal();
      s < l && this.pageChange({ skip: s, take: t }, e);
    }, this.moveToPrevPage = (e) => {
      const t = this.props.take || 0, s = (this.props.skip || 0) - t;
      s >= 0 && this.pageChange({ skip: s, take: t }, e);
    }, this.pagerPageChange = (e) => {
      this.pageChange({ skip: e.skip, take: e.take }, e.syntheticEvent, e.targetEvent);
    }, this.sortChange = (e, t) => {
      this.raiseDataEvent(
        this.props.onSortChange,
        { sort: e },
        { sort: e, ...this.props.scrollable === "virtual" ? { skip: 0 } : {} },
        t
      );
    }, this.filterChange = (e, t) => {
      this.raiseDataEvent(
        this.props.onFilterChange,
        { filter: e },
        { filter: e || void 0, skip: 0 },
        t
      );
    }, this.groupChange = (e, t) => {
      const s = t.nativeEvent ? t : { nativeEvent: t.nativeEvent || t.originalEvent };
      e.length === 0 && this.props.navigatable && (this._focusFirst = !0), this._columnsMutations++, this.raiseDataEvent(
        this.props.onGroupChange,
        { group: e },
        { group: e, skip: 0 },
        s
      );
    }, this.onClipboard = (e, t) => {
      if (this.props.onClipboard) {
        if (!this.inActiveElement() || !e)
          return;
        this.props.onClipboard.call(
          void 0,
          {
            type: e,
            nativeEvent: t,
            columns: this._columns,
            dataItemKey: this.props.dataItemKey || "",
            ...typeof this.props.clipboard != "boolean" ? this.props.clipboard : {}
          }
        );
      }
    }, this.inActiveElement = () => {
      var p, n, d;
      if (!L)
        return !1;
      const e = Oe(this.document), t = e ? e.matches(".k-table-td") ? e : (p = this.document) == null ? void 0 : p.body : (n = this.document) == null ? void 0 : n.body, s = t.closest(".k-grid-container"), l = t && ((d = this._element) == null ? void 0 : d.contains(t));
      return !!(t && l && s);
    }, this.onResize = (e, t, s, l, p, n) => {
      this.resetTableWidth(), this._shouldUpdateLeftRight = !0, this._resized = !0, this._columnsMutations++, this.props.onColumnResize && this.props.onColumnResize.call(
        void 0,
        {
          columns: this.columns,
          nativeEvent: l,
          targetColumnId: n,
          index: e,
          newWidth: t,
          oldWidth: s,
          end: p,
          target: this
        }
      );
    }, this.reInitVirtualization = S((e, t, s, l, p, n) => {
      this.vs.reset();
      const d = this.getVirtualScroll(this.props);
      this.vs = new d(n);
    }), this.flatData = S((e, t, s, l, p, n, d) => {
      const f = [], R = gt(
        f,
        e,
        t,
        { index: s },
        l !== void 0,
        p
      );
      return { flattedData: f, resolvedGroupsCount: R };
    }), this.rowHeightService = S((e, t, s, l, p) => new re(t, s, l, p)), this.childrenToArray = S((e) => r.Children.toArray(e)), this.readColumns = S(
      (e, t, s) => {
        const l = e.filter((p) => p && p.type && p.type.displayName === "KendoReactGridColumn");
        return mt(l, this.columns, { prevId: 0, idPrefix: t });
      }
    ), this.mapColumns = S(
      (e, t) => We(e, !0)
    ), this.filterHiddenColumns = (e) => {
      const t = (s) => {
        const l = s;
        return {
          ...l,
          props: {
            ...l.props,
            children: l.props.children && l.props.children.length > 0 ? this.filterHiddenColumns(l.props.children) : l.props.children
          }
        };
      };
      return [...e].filter((s) => r.isValidElement(s) && !s.props.hidden).filter((s) => L && s && r.isValidElement(s) && s.props.media ? window.matchMedia(s.props.media).matches : s).map((s) => t(s));
    }, this.configureColumns = S((e, t, s) => {
      this.props.selectedField && e.filter((n) => n.field === this.props.selectedField).forEach((n) => {
        n.width = n.width || "50px", n.cell = n.cell || Ze, n.headerCell = n.headerCell || yt;
      });
      const l = {
        id: "",
        resizable: !0,
        width: "32px",
        title: " ",
        declarationIndex: -1,
        orderIndex: -1,
        children: [],
        parentIndex: -1,
        depth: 0,
        colSpan: 0,
        rowSpan: 0,
        left: 0,
        right: 0,
        index: 0,
        rightBorder: !1,
        ariaColumnIndex: 0,
        isAccessible: !0
      };
      let p = 0;
      this.props.expandField && this.props.onExpandChange && this.props.detail && (e.unshift({
        ...l,
        cell: et,
        field: this.props.expandField,
        headerClassName: "k-hierarchy-cell k-header"
      }), p++);
      for (let n = 0; n < t; n++)
        e.unshift({
          ...l,
          isAccessible: !1,
          cell: be,
          field: "value",
          locked: this.props.lockGroups
        }), p++;
      e.slice(p).forEach((n) => n.parentIndex >= 0 && (n.parentIndex += p));
    }), this.getHeaderRow = S((e, t, s, l, p, n, d, f, R, E, D, C, A) => /* @__PURE__ */ r.createElement(
      it,
      {
        cells: this.props.cells,
        sort: e,
        sortable: t,
        sortChange: this.sortChange,
        group: s || [],
        groupable: l,
        groupChange: this.groupChange,
        filter: p,
        filterable: n,
        filterOperators: d,
        filterChange: this.filterChange,
        columnMenu: R,
        columnMenuIcon: E,
        selectionChange: this.onHeaderSelectionChange,
        columns: D,
        columnResize: this.columnResize,
        pressHandler: this.dragLogic.pressHandler,
        dragHandler: this.dragLogic.dragHandler,
        releaseHandler: this.dragLogic.releaseHandler,
        columnsMap: C,
        cellRender: f,
        isRtl: A,
        dragClue: this.dragLogic.dragClueRef,
        headerRef: this.headerElementRef,
        containerRef: this.containerRef,
        navigatable: this.props.navigatable,
        columnGroupChange: this.columnGroupChange
      }
    )), this.resolveTitle = (e) => {
      const t = this._columns.find((l) => l.field === e), s = t && (t.title || t.field);
      return s === void 0 ? e : s;
    }, this.getLeafDataItems = () => this._data.filter((e) => e.rowType === "data").map((e) => e.dataItem), this.getSlicedLeafDataItems = () => (this._slicedData || this._data).filter((e) => e.rowType === "data").map((e) => e.dataItem), Ke(Re), this.showLicenseWatermark = Ve(Re);
    const h = this.props.groupable === !0 || typeof this.props.groupable == "object" && this.props.groupable.enabled !== !1, c = this.getVirtualScroll(a);
    this.vs = new c(h || a.rowHeight === void 0 || a.rowHeight === 0), this.dragLogic = new ut(
      this.columnReorder.bind(this),
      this.groupReorder.bind(this),
      this.columnToGroup.bind(this)
    ), this.columnGroupChange = this.columnGroupChange.bind(this), this.columnResize = new ct(this.onResize), this.props.clipboard && (this.clipboardService = new $e(this.onClipboard)), _.onConstructor({
      navigatable: !!a.navigatable,
      contextStateRef: this.contextStateRef,
      navigationStateRef: this.navigationStateRef,
      idPrefix: this._gridId
    });
  }
  /* eslint-disable max-len */
  /**
   * A getter of the current columns. Gets the current column width or current columns, or any other [`GridColumnProps`]({% slug api_grid_gridcolumnprops %}) for each defined column. Can be used on each Grid instance. To obtain the instance of the rendered Grid, use the `ref` callback. The following example demonstrates how to reorder the columns by dragging their handlers and check the properties afterwards. You can check the result in the browser console.
   *
   * @example
   * ```jsx
   * class App extends React.Component {
   *     constructor(props) {
   *         super(props);
   *         this.state = {
   *             data: [
   *                 { 'foo': 'A1', 'bar': 'B1' },
   *                 { 'foo': 'A2', 'bar': 'B2' },
   *                 { 'foo': 'A3', 'bar': 'B2' }
   *             ]
   *         };
   *         this.grid = null;
   *     }
   *     render() {
   *         return (
   *             <div>
   *                 <Grid
   *                     data={this.state.data}
   *                     reorderable={true}
   *                     ref={(g) => { this.grid = g; }}
   *                 >
   *                     <GridColumn field="foo" />
   *                     <GridColumn field="bar" />
   *                 </Grid>
   *                 <button onClick={() => console.log(JSON.stringify(this.grid.columns))}>
   *                     log current properties into browser console.
   *                 </button>
   *             </div>
   *         );
   *     }
   * }
   * ReactDOM.render(<App />, document.querySelector('my-app'));
   * ```
   */
  // tslint:enable:max-line-length
  get columns() {
    const a = this._columns.filter((h) => h.declarationIndex >= 0 && h.parentIndex === -1);
    return ft(a);
  }
  /**
   * Returns the HTML element of the Grid component.
   */
  get element() {
    return this._element;
  }
  get document() {
    if (L)
      return this.element && this.element.ownerDocument || document;
  }
  get _header() {
    return this.headerRef.current;
  }
  get _gridId() {
    return this.props.id + "-role-element-id";
  }
  /**
   * @hidden
   */
  componentDidMount() {
    var c;
    this.props.columnVirtualization && !navigator.userAgent.match(xt) && (this.headTable && (this.headTable.style.display = "block"), this.tableElement && (this.tableElement.style.display = "block")), this.resetTableWidth(), ae();
    const a = je(this.element);
    this.isRtl = a, _.onComponentDidMount({
      scope: this.element || void 0,
      contextStateRef: this.contextStateRef,
      navigationStateRef: this.navigationStateRef
    }), this.isRtl && this.forceUpdate();
    const h = {
      rootMargin: "0px",
      threshold: 0.9
    };
    this.clipboardService && this.clipboardService.addEventListeners(this.document), this.observer = L && window.IntersectionObserver && new window.IntersectionObserver(this.handleIntersection, h) || null, this.resizeObserver = L && window.ResizeObserver && new window.ResizeObserver(this.calculateMedia.bind(this)), (c = this.document) != null && c.body && this.resizeObserver && this.resizeObserver.observe(this.document.body);
  }
  /**
   * @hidden
   */
  getSnapshotBeforeUpdate() {
    return _.onGetSnapshotBeforeUpdate({
      document: this.document,
      contextStateRef: this.contextStateRef,
      navigationStateRef: this.navigationStateRef
    }), null;
  }
  /**
   * @hidden
   */
  componentDidUpdate() {
    this.resetTableWidth(), ae(), this.vs.tableTransform && this.vs.table && (this.vs.table.style.transform = this.vs.tableTransform, this.vs.tableTransform = ""), _.onComponentDidUpdate({
      scope: this.element || void 0,
      contextStateRef: this.contextStateRef,
      navigationStateRef: this.navigationStateRef,
      focusFirst: this._focusFirst
    }), this._focusFirst = !1;
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    var a;
    clearTimeout(this.forceUpdateTimeout), this.clipboardService && this.clipboardService.removeEventListeners(this.document), (a = this.document) != null && a.body && this.resizeObserver && this.resizeObserver.disconnect();
  }
  /**
   * @hidden
   */
  render() {
    var ie;
    let a = this.props.total || 0;
    const h = k.getIdPrefix(this.navigationStateRef), c = lt(this);
    let e = [];
    Array.isArray(this.props.data) ? (e = this.props.data, a = a || this.props.data.length) : this.props.data && (e = this.props.data.data, a = a || this.props.data.total);
    const t = typeof this.props.groupable == "object" && this.props.groupable.footer || "none", s = this.props.scrollable === "virtual", { resolvedGroupsCount: l, flattedData: p } = this.flatData(
      e,
      t,
      this.props.skip || 0,
      this.props.group,
      this.props.expandField,
      this.props.filter,
      this.props.sort
    );
    this._data = p;
    const n = this.props.groupable === !0 || typeof this.props.groupable == "object" && this.props.groupable.enabled !== !1;
    this.columnResize.resizable = this.props.resizable || !1, this.dragLogic.reorderable = this.props.reorderable || !1, this.dragLogic.groupable = n;
    const d = this.props.selectable && this.props.selectable.drag ? "none" : void 0;
    this.initializeVirtualization(a, n);
    const f = this.childrenToArray(this.props.children);
    this.initColumns(f, l);
    const R = f.map((i) => i && i.type && i.type.displayName === "KendoReactGridToolbar" ? r.cloneElement(i, { ...i.props, ariaControls: this._gridId }) : null), E = f.filter((i) => i && i.type && i.type.displayName === "KendoReactGridNoRecords"), D = f.filter((i) => i && i.type && i.type.displayName === "KendoReactGridStatusBar"), C = this._columns.filter((i) => i.children.length === 0), A = n && /* @__PURE__ */ r.createElement(
      rt,
      {
        group: this.props.group || [],
        groupChange: this.groupChange,
        pressHandler: this.dragLogic.pressHandler,
        dragHandler: this.dragLogic.dragHandler,
        releaseHandler: this.dragLogic.releaseHandler,
        refCallback: this.dragLogic.refGroupPanelDiv,
        resolveTitle: this.resolveTitle,
        ariaControls: this._gridId,
        onContextMenu: this.onContextMenu
      }
    ), { sort: ye, sortable: we, group: Se, filter: Ie, filterable: ke, filterOperators: Ee = Ce, headerCellRender: xe, columnMenu: _e, columnMenuIcon: ze } = this.props, j = /* @__PURE__ */ r.createElement(
      st,
      {
        size: this.props.size,
        columnResize: this.columnResize,
        staticHeaders: this.props.scrollable !== "none",
        scrollableDataElement: () => this.vs.container,
        draggable: this.props.reorderable || n,
        ref: this.headerRef,
        elemRef: this.headerElementRef,
        headerRow: this.getHeaderRow(
          ye,
          we,
          Se,
          n,
          Ie,
          ke,
          Ee,
          xe,
          _e,
          ze,
          this._columns,
          this._columnsMap,
          this.isRtl
        ),
        filterRow: this.props.filterable && /* @__PURE__ */ r.createElement(
          ot,
          {
            cells: this.props.cells,
            size: this.props.size,
            columns: this._columns,
            filter: this.props.filter,
            filterOperators: this.props.filterOperators || Ce,
            filterChange: this.filterChange,
            sort: this.props.sort,
            cellRender: this.props.filterCellRender,
            isRtl: this.isRtl,
            ariaRowIndex: this._columnsMap.length + 1
          }
        ) || void 0,
        cols: C.map((i, g) => /* @__PURE__ */ r.createElement(
          "col",
          {
            key: g.toString(),
            width: W(i)
          }
        ))
      }
    ), De = this.vs && this.vs.container && this.vs.container.scrollLeft || 0, Te = parseFloat(((this.props.style || {}).width || "").toString()), { colSpans: He, hiddenColumns: Fe } = qe({
      enabled: this.props.columnVirtualization,
      columns: C,
      tableViewPortWidth: Te,
      scrollLeft: De
    }), Ne = (i, g, m) => {
      let x = !1;
      const I = this.props.selectedField ? ve(this.props.selectedField, i.dataItem) : void 0;
      return {
        row: C.map((u, v) => {
          if (Fe[v])
            return null;
          const H = u.id ? u.id : v, F = `${u.className ? u.className + " " : ""}${u.locked ? "k-grid-content-sticky" : ""}`, y = u.left !== void 0 ? this.isRtl ? { left: u.right, right: u.left } : { left: u.left, right: u.right } : {};
          let w = !1;
          if (u.editable && this.props.editField) {
            const b = ve(this.props.editField, i.dataItem);
            b && (b === !0 || b === u.field) && (x = !0, w = !0);
          }
          const U = u.cell || w && tt || Ct, N = this.props.expandField && this.props.detail && u.field === this.props.expandField;
          return /* @__PURE__ */ r.createElement(
            U,
            {
              onContextMenu: this.onContextMenu,
              key: H,
              locked: this.props.lockGroups,
              id: k.generateNavigatableId(
                `${g}-${String(v)}`,
                h,
                N || i.rowType === "groupHeader" || i.rowType === "groupFooter" || u.field === "value" ? "nodata" : "cell"
              ),
              colSpan: He[v],
              dataItem: i.dataItem,
              field: u.field,
              editor: u.editor,
              format: u.format,
              className: F,
              render: this.props.cellRender,
              cells: bt(this.props.cells, u.cells),
              onChange: this.itemChange,
              selectionChange: this.props.onSelectionChange ? (b) => {
                this.selectionChange({ event: b, dataItem: i.dataItem, dataIndex: m, columnIndex: v });
              } : void 0,
              columnIndex: v,
              columnsCount: C.length,
              rowType: i.rowType,
              level: i.level,
              expanded: i.expanded,
              dataIndex: i.dataIndex,
              style: y,
              ariaColumnIndex: u.ariaColumnIndex,
              isSelected: Array.isArray(I) && I.indexOf(v) > -1
            }
          );
        }),
        isInEdit: x,
        isSelected: typeof I == "boolean" && I
      };
    };
    let q = 0;
    if (s)
      for (let i = 0; i < this.vs.topCacheCount + this.vs.attendedSkip - (this.props.skip || 0); i++) {
        const g = this._data.shift();
        if (g)
          this._data.push(g), q++, g.rowType === "groupHeader" && i--;
        else
          break;
      }
    const J = (i) => i >= this._data.length - q;
    let X = this.vs.realSkip || 0;
    const P = [];
    let K = !1;
    const V = this._columnsMap.length + (this.props.filterable ? 1 : 0) + 1;
    let T = 0;
    if (this._data.length) {
      let i = -1, g = 0;
      (this._slicedData || this._data).forEach((m, x) => {
        m.rowType === "data" && (X++, i++);
        const I = X % 2 === 0, u = this.props.dataItemKey && Ue(this.props.dataItemKey)(m.dataItem), v = x + (this.vs.realSkip || 0), H = u || "ai" + v, F = H + "_1", y = Ne(m, H, i);
        if (T = v + V + g, P.push(/* @__PURE__ */ r.createElement(
          Rt,
          {
            key: H,
            dataItem: m.dataItem,
            isAltRow: I,
            isInEdit: y.isInEdit,
            rowType: m.rowType,
            isHidden: J(x),
            onClick: (w) => this.rowClick(w, m),
            onDoubleClick: (w) => this.rowDblClick(w, m),
            selectedField: this.props.selectedField,
            rowHeight: this.props.rowHeight,
            render: this.props.rowRender,
            ariaRowIndex: T,
            absoluteRowIndex: v,
            dataIndex: this.vs.scrollableVirtual && !this.props.groupable ? v : i,
            isSelected: y.isSelected
          },
          y.row
        )), this.props.detail && m.rowType === "data" && m.expanded) {
          const w = C.length - (this.props.expandField ? 1 : 0) - (this.props.group ? this.props.group.length : 0) || 1;
          g++, T = v + V + g, P.push(/* @__PURE__ */ r.createElement(
            "tr",
            {
              key: F,
              className: M(
                "k-table-row",
                I ? "k-detail-row k-table-alt-row k-alt" : "k-detail-row"
              ),
              style: { visibility: J(x) ? "hidden" : "", height: this.props.detailRowHeight },
              role: "row",
              "aria-rowindex": T
            },
            this.props.group && this.props.group.map((U, N) => {
              var oe;
              const b = (oe = y == null ? void 0 : y.row[N]) == null ? void 0 : oe.props.style, Pe = b ? this.isRtl ? { left: b.right, right: b.left } : { left: b.left, right: b.right } : {};
              return /* @__PURE__ */ r.createElement(
                be,
                {
                  id: "",
                  dataIndex: m.dataIndex,
                  field: U.field,
                  dataItem: m.dataItem,
                  key: N,
                  style: Pe,
                  ariaColumnIndex: 1 + N,
                  isSelected: !1,
                  locked: this.props.lockGroups,
                  isRtl: this.isRtl,
                  cells: this.props.cells
                }
              );
            }),
            this.props.expandField && /* @__PURE__ */ r.createElement(
              Et,
              {
                id: k.generateNavigatableId(`${F}-dhcell`, h)
              }
            ),
            /* @__PURE__ */ r.createElement(
              kt,
              {
                onContextMenu: this.onContextMenu,
                dataItem: m.dataItem,
                dataIndex: m.dataIndex,
                colSpan: w,
                ariaColIndex: 2 + (this.props.group ? this.props.group.length : 0),
                detail: this.props.detail,
                id: k.generateNavigatableId(`${F}-dcell`, h)
              }
            )
          ));
        }
      });
    } else
      K = !0;
    const Le = () => {
      const i = this._header;
      return i && i.table && i.table.clientWidth;
    }, Y = () => /* @__PURE__ */ r.createElement(
      "div",
      {
        key: "no-records",
        className: "k-grid-norecords",
        "aria-rowindex": V,
        style: { width: Le() }
      },
      /* @__PURE__ */ r.createElement("div", { className: "k-grid-norecords-template", [Qe]: k.generateNavigatableId("no-records", h) }, E.length ? E : /* @__PURE__ */ r.createElement(wt, null))
    ), Q = {
      size: this.props.size,
      onPageChange: this.pagerPageChange,
      total: a,
      dir: this.isRtl ? "rtl" : void 0,
      skip: this.vs.propsSkip || 0,
      take: (this.props.take !== void 0 ? this.props.take : this.props.pageSize) || 10,
      messagesMap: ht,
      navigatable: this.props.navigatable,
      ...It(this.props.pageable || {})
    }, Z = this.props.pager ? /* @__PURE__ */ r.createElement(this.props.pager, { ...Q }) : /* @__PURE__ */ r.createElement(Je, { className: "k-grid-pager", ...Q }), Me = (i) => this.props.sort && this.props.sort.filter((g) => g.field === i).length > 0, Ae = (i, g) => /* @__PURE__ */ r.createElement(
      "col",
      {
        key: g.toString(),
        width: W(i)
      }
    ), ee = (ie = this.props.cells) != null && ie.footerCell || this._columns.some(
      (i) => {
        var g;
        return !!(i.footerCell || (g = i.cells) != null && g.footerCell);
      }
    ) ? /* @__PURE__ */ r.createElement(
      at,
      {
        size: this.props.size,
        columnResize: this.columnResize,
        staticHeaders: this.props.scrollable !== "none",
        ref: (i) => this._footer = i,
        row: /* @__PURE__ */ r.createElement(
          St,
          {
            cells: this.props.cells,
            idPrefix: h,
            columns: this._columns,
            isRtl: this.isRtl,
            ariaRowIndex: T + 1
          }
        ),
        cols: C.map(Ae)
      }
    ) : null, te = /* @__PURE__ */ r.createElement(
      "colgroup",
      {
        ref: (i) => {
          this.columnResize.colGroupMain = i;
        }
      },
      C.map(
        (i, g) => /* @__PURE__ */ r.createElement(
          "col",
          {
            key: g.toString(),
            className: Me(i.field) ? "k-sorted" : void 0,
            width: W(i)
          }
        )
      )
    ), se = this.dragLogic.reorderable || this.dragLogic.groupable;
    if (this.props.scrollable === "none")
      return /* @__PURE__ */ r.createElement(B.Provider, { value: this.contextStateRef.current }, /* @__PURE__ */ r.createElement(
        "div",
        {
          id: this.props.id,
          style: this.props.style,
          className: M(
            "k-grid",
            {
              "k-grid-md": !this.props.size,
              [`k-grid-${O.sizeMap[this.props.size] || this.props.size}`]: this.props.size
            },
            this.props.className
          ),
          ref: (i) => {
            this._element = i;
          },
          "aria-label": this.props.ariaLabel,
          onKeyDown: this.onKeyDown,
          onFocus: this.onFocus,
          ...ne
        },
        R,
        A,
        /* @__PURE__ */ r.createElement(
          he,
          {
            selectable: this.props.selectable,
            onRelease: this.selectionRelease,
            childRef: (i) => {
              this.tableElement = i, this.headTable = i;
            }
          },
          /* @__PURE__ */ r.createElement(
            "table",
            {
              ref: (i) => this.headTable = i,
              className: M(
                "k-table k-grid-table",
                { [`k-table-${O.sizeMap[this.props.size] || this.props.size}`]: this.props.size }
              ),
              style: { userSelect: d }
            },
            te,
            j,
            /* @__PURE__ */ r.createElement("tbody", { role: "rowgroup", className: "k-table-tbody", ...pe }, P),
            ee
          )
        ),
        K && Y(),
        se && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(de, { ref: this.dragLogic.refDropElementClue }), /* @__PURE__ */ r.createElement(ce, { ref: this.dragLogic.refDragElementClue }))
      ), D, this.props.pageable && Z);
    let G = this.props.style || {};
    return s && (G.height || (G = Object.assign({}, G, { height: "450px" }))), /* @__PURE__ */ r.createElement(B.Provider, { value: this.contextStateRef.current }, /* @__PURE__ */ r.createElement(
      "div",
      {
        id: this.props.id,
        style: G,
        className: M(
          "k-grid",
          {
            "k-grid-md": !this.props.size,
            [`k-grid-${O.sizeMap[this.props.size] || this.props.size}`]: this.props.size,
            "k-grid-virtual": s
          },
          this.props.className
        ),
        ref: (i) => {
          this._element = i;
        },
        "aria-label": this.props.ariaLabel,
        onKeyDown: this.onKeyDown,
        onFocus: this.onFocus,
        ...ne
      },
      R,
      A,
      /* @__PURE__ */ r.createElement(
        "div",
        {
          className: "k-grid-aria-root",
          role: "grid",
          "aria-colcount": C.length,
          "aria-rowcount": a,
          id: this._gridId,
          "aria-label": c.toLanguageString(ue, pt[ue])
        },
        j,
        /* @__PURE__ */ r.createElement("div", { className: "k-grid-container", role: "presentation" }, /* @__PURE__ */ r.createElement(
          "div",
          {
            ref: this.containerRef,
            className: "k-grid-content k-virtual-content",
            onScroll: this.scrollHandler,
            role: "presentation"
          },
          /* @__PURE__ */ r.createElement("div", { className: "k-grid-table-wrap", role: "presentation" }, /* @__PURE__ */ r.createElement(
            he,
            {
              selectable: this.props.selectable,
              onRelease: this.selectionRelease,
              childRef: (i) => {
                this.tableElement = i;
              }
            },
            /* @__PURE__ */ r.createElement(
              "table",
              {
                ref: (i) => this.tableElement = i,
                className: M(
                  "k-table k-grid-table",
                  {
                    "k-table-md": !this.props.size,
                    [`k-table-${O.sizeMap[this.props.size] || this.props.size}`]: this.props.size
                  }
                ),
                role: "presentation",
                style: { userSelect: d }
              },
              te,
              /* @__PURE__ */ r.createElement(
                "tbody",
                {
                  className: "k-table-tbody",
                  ref: this.tableBodyRef,
                  role: "rowgroup",
                  ...pe
                },
                P
              )
            )
          ), K && Y()),
          s && /* @__PURE__ */ r.createElement("div", { className: "k-height-container", role: "presentation" }, /* @__PURE__ */ r.createElement(
            "div",
            {
              style: s ? { height: this.vs.containerHeight + "px" } : {}
            }
          ))
        )),
        ee,
        se && /* @__PURE__ */ r.createElement(r.Fragment, null, /* @__PURE__ */ r.createElement(de, { ref: this.dragLogic.refDropElementClue }), /* @__PURE__ */ r.createElement(ce, { ref: this.dragLogic.refDragElementClue })),
        this.showLicenseWatermark && /* @__PURE__ */ r.createElement(Be, null)
      ),
      D,
      this.props.pageable && Z
    ));
  }
  calculateMedia() {
    this.checkMatchMediaColumnsDifferece() || this.forceUpdate();
  }
  selectionChange(a) {
    if (this.props.onSelectionChange) {
      const { event: h, dataItem: c, dataIndex: e, columnIndex: t } = a, { mode: s, cell: l } = le(this.props.selectable), p = {
        ...this.getArguments(h.syntheticEvent),
        dataItem: c,
        startColIndex: t,
        endColIndex: t,
        startRowIndex: e,
        endRowIndex: e,
        dataItems: this.getLeafDataItems(),
        altKey: !1,
        ctrlKey: !1,
        shiftKey: !1,
        metaKey: !1,
        mode: s,
        cell: l,
        isDrag: !1,
        componentId: this._gridId,
        selectedField: this.props.selectedField || ""
      };
      this.props.onSelectionChange.call(void 0, p);
    }
  }
  raiseDataEvent(a, h, c, e, t) {
    const s = this.props.onDataStateChange;
    if (a) {
      const l = { ...this.getArguments(e), ...h, targetEvent: t };
      a.call(void 0, l);
    } else
      s && s.call(
        void 0,
        {
          ...this.getArguments(e),
          targetEvent: t || {},
          dataState: {
            ...this.getDataState(),
            ...c
          }
        }
      );
  }
  columnReorder(a, h, c) {
    const e = this._columns[a], t = e.depth, s = (d) => {
      do
        d++;
      while (d < this._columns.length && this._columns[d].depth > t);
      return d;
    }, l = this._columns.splice(a, s(a) - a);
    this._columns.splice(a < h ? s(h - l.length) : h, 0, ...l), this._columns.filter((d) => d.declarationIndex >= 0).forEach((d, f) => d.orderIndex = f), this._columnsMutations++;
    const p = this._columns[a].locked && this._columns[h].locked;
    Xe(this._columnsMap, this._columns, p || this._shouldUpdateLeftRight), Ye(this._columnsMap, this._columns, p || this._shouldUpdateLeftRight), this._resized && (this._shouldUpdateLeftRight = !1, this._resized = !1);
    const n = this.columns;
    if (this.forceUpdate(), this.props.onColumnReorder) {
      const d = {
        target: this,
        columns: n,
        columnId: e.id,
        nativeEvent: c
      };
      this.props.onColumnReorder.call(void 0, d);
    }
  }
  groupReorder(a, h, c) {
    if (this.props.group === void 0)
      return;
    const e = this.props.group.slice();
    e.splice(h, 0, ...e.splice(a, 1)), this.groupChange(e, c);
  }
  columnToGroup(a, h, c) {
    const e = this._columns[a].field;
    if (!e)
      return;
    const t = (this.props.group || []).slice();
    t.splice(h, 0, { field: e }), this.groupChange(t, c);
  }
  columnGroupChange(a, h) {
    const c = this.dragLogic.getCurrentGroupsLength;
    this.columnToGroup(a, c, h);
  }
  resetTableWidth() {
    let a = 0;
    if (!this.columnResize.colGroupMain)
      return;
    const h = this.columnResize.colGroupMain.children;
    for (let c = 0; c < h.length; c++) {
      const e = h[c].width;
      if (!e)
        return;
      a += parseFloat(e.toString());
    }
    a = Math.round(a), this._header && this._header.setWidth(a), this._footer && this._footer.setWidth(a), this.tableElement && (this.tableElement.style.width = a + "px");
  }
  initColumns(a, h) {
    const c = k.getIdPrefix(this.navigationStateRef), e = this.filterHiddenColumns(a), t = this.readColumns(e, c, this._columnsMutations);
    this._columns = t, this._columns.length === 0 && (this._columns = vt(this.props.data, this.props.group, this.props.expandField, { prevId: 0, idPrefix: c })), this.configureColumns(this._columns, h, c), this._columnsMap = this.mapColumns(this._columns, this._columnsMutations), this.columnResize.columns = this._columns, this.dragLogic.columns = this._columns;
  }
  getDataState() {
    return {
      filter: this.props.filter,
      sort: this.props.sort,
      skip: this.props.skip,
      take: this.props.take !== void 0 ? this.props.take : this.props.pageSize,
      group: this.props.group
    };
  }
  getArguments(a) {
    return {
      nativeEvent: a && a.nativeEvent,
      syntheticEvent: a,
      target: this
    };
  }
};
z.displayName = "KendoReactGrid", z.defaultProps = {
  // never use this
}, z.propTypes = {
  data: o.oneOfType([
    o.array,
    o.shape({
      data: o.array,
      total: o.number
    })
  ]),
  sortable: o.oneOfType([
    o.bool,
    o.shape({
      mode: o.oneOf(["single", "multiple"]),
      allowUnsort: o.bool
    })
  ]),
  onSortChange: o.func,
  sort: o.array,
  filterable: o.bool,
  filter: o.any,
  onFilterChange: o.func,
  pageable: o.oneOfType([
    o.bool,
    o.shape({
      buttonCount: o.number,
      responsive: o.bool,
      info: o.bool,
      type: o.oneOf(["numeric", "input"]),
      pageSizes: o.oneOfType(
        [
          o.bool,
          o.arrayOf(o.oneOfType([
            o.string,
            o.number
          ]))
        ]
      ),
      previousNext: o.bool
    })
  ]),
  pageSize: o.number,
  onPageChange: o.func,
  total: o.number,
  skip: o.number,
  take: o.number,
  fixedScroll: o.bool,
  onExpandChange: o.func,
  expandField: o.string,
  selectedField: o.string,
  onSelectionChange: o.func,
  onHeaderSelectionChange: o.func,
  resizable: o.bool,
  reorderable: o.bool,
  group: o.any,
  groupable: o.oneOfType([
    o.bool,
    o.shape({
      enabled: o.bool,
      footer: o.oneOf(["always", "visible", "none"])
    })
  ]),
  onGroupChange: o.func,
  onRowClick: o.func,
  onRowDoubleClick: o.func,
  onItemChange: o.func,
  editField: o.string,
  scrollable: o.oneOf(["none", "scrollable", "virtual"]),
  rowHeight: o.number,
  detailRowHeight: o.number,
  detail: o.any,
  style: o.object,
  onDataStateChange: o.func,
  onColumnResize: o.func,
  onColumnReorder: o.func,
  dataItemKey: o.string,
  navigatable: o.bool,
  size: o.oneOf(["small", "medium"])
}, z.contextType = B;
let $ = z;
nt($);
export {
  $ as Grid
};
