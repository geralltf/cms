/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as a from "react";
import { firefox as f } from "./utils/index.mjs";
class p {
  constructor(t) {
    this.table = null, this.containerHeight = 0, this.topCacheCount = 0, this.attendedSkip = 0, this.propsSkip = 0, this.total = 0, this.scrollableVirtual = !1, this.realSkip = 0, this.pageSize = 0, this.PageChange = null, this.tableBodyRef = a.createRef(), this.fixedScroll = !1, this.askedSkip = void 0, this.containerRef = a.createRef(), this.tableTransform = "", this.scrollSyncing = !1, this.lastLoaded = 0, this.firstLoaded = 0, this.lastScrollTop = 0, this.reactVersion = Number.parseFloat(a.version), this.firstLoaded = this.pageSize, this.lastLoaded = this.realSkip + this.pageSize, this.scrollHandler = this.scrollHandler.bind(this);
  }
  get container() {
    return this.containerRef.current;
  }
  translate(t, i) {
    this.scrollableVirtual && this.table && (f || this.reactVersion <= 17 || i ? this.table.style.transform = "translateY(" + t + "px)" : this.tableTransform = "translateY(" + t + "px)");
  }
  changePage(t, i) {
    this.PageChange && this.PageChange({ skip: Math.max(0, t), take: this.pageSize }, i);
  }
  reset() {
    this.scrollSyncing = !0, !this.fixedScroll && (this.container && (this.container.scrollTop = 0), this.translate(0, !0));
  }
  scrollHandler(t) {
    if (!this.scrollableVirtual || !this.container || !this.table || !this.rowHeightService || !this.containerRef.current)
      return;
    if (this.scrollSyncing) {
      this.scrollSyncing = !1;
      return;
    }
    const i = this.container.scrollTop, r = this.lastScrollTop >= i, o = !r;
    this.lastScrollTop = i;
    let e = this.rowHeightService.index(i), h = this.rowHeightService.offset(e);
    const { offsetHeight: l } = this.containerRef.current, n = this.rowHeightService.index(i + l);
    if (o && n >= this.lastLoaded && this.lastLoaded < this.total) {
      const s = e + this.pageSize - this.total;
      s > 0 && (e = e - s, h = this.rowHeightService.offset(e)), this.firstLoaded = e, this.translate(h);
      const c = this.firstLoaded + this.pageSize;
      this.lastLoaded = Math.min(c, this.total), this.changePage(this.firstLoaded, t);
    } else if (r && e < this.firstLoaded) {
      const s = Math.floor(this.pageSize * 0.3);
      this.firstLoaded = Math.max(e - s, 0), this.translate(this.rowHeightService.offset(this.firstLoaded)), this.lastLoaded = Math.min(this.firstLoaded + this.pageSize, this.total), this.changePage(this.firstLoaded, t);
    }
  }
}
export {
  p as VirtualScrollFixed
};
