/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { guid as S, getActiveElement as A, Keys as l } from "@progress/kendo-react-common";
import { focusFirstDataElement as D, getFirstDataCell as N, tableKeyboardNavigationTools as o, getCurrentIdIndexes as F, getFirstRowDataCell as w, getLastRowDataCell as M, getLastDataCell as L, getHeaderElement as P, getBodyElement as K, getNoRecordsElement as T, getNavigatableId as B, findNextIdByRowIndex as H, findNextIdByCellIndex as U } from "./utils.mjs";
const R = (e) => {
  const { navigatable: c, contextStateRef: a, navigationStateRef: t, idPrefix: r } = e;
  c && (a.current = {
    activeId: "",
    level: 0
  }, t.current = {
    activeElementIsFocused: !1,
    prevNavigationIndexes: void 0,
    idPrefix: r || S(),
    navigationMatrix: [],
    lastHeaderIndex: -1
  });
}, h = (e) => {
  const { scope: c, contextStateRef: a, navigationStateRef: t } = e;
  if (a.current && t.current && c) {
    b(e);
    const r = N(t.current.navigationMatrix);
    if (r) {
      const n = o.getActiveNavDataElement(c, r);
      n && (a.current.activeId = r, n.setAttribute("tabIndex", "0"));
    }
  }
}, O = (e) => {
  const { contextStateRef: c, navigationStateRef: a, document: t } = e;
  if (c.current && a.current && t) {
    const r = A(t), n = o.getNavigatableId(r);
    n && n === c.current.activeId && (a.current.activeElementIsFocused = !0);
  }
}, G = (e) => {
  const { scope: c, contextStateRef: a, navigationStateRef: t, focusFirst: r } = e;
  if (r && (R(e), h(e), D(e)), b(e), a.current && t.current && c) {
    if (!o.getActiveNavDataElement(c, a.current.activeId)) {
      const f = N(t.current.navigationMatrix), i = o.getActiveNavDataElement(c, f);
      f && i && (a.current.activeId = f, i.setAttribute("tabIndex", "0"), t.current.activeElementIsFocused && i.focus());
    }
    t.current.activeElementIsFocused = !1;
  }
}, V = (e, c) => {
  const { contextStateRef: a } = c;
  if (e.isDefaultPrevented() || !a.current)
    return;
  const t = e.target, r = o.getNavigatableId(t);
  if (r && r !== a.current.activeId) {
    const n = o.getClosestScope(t);
    if (!n)
      return;
    const f = o.getActiveNavDataElement(n, a.current.activeId);
    f && !e.target.classList.contains("k-table-td") && !e.target.classList.contains("k-detail-cell") && f.setAttribute("tabIndex", "-1"), t.setAttribute("tabIndex", "0"), a.current.activeId = r;
  }
}, W = (e, c) => {
  const {
    contextStateRef: a,
    navigationStateRef: t,
    onNavigationAction: r
  } = c;
  if (e.isDefaultPrevented() || !a.current || !t.current)
    return;
  let n;
  if (e.keyCode === l.esc) {
    n = o.getClosestNavigatableElement(e.target), o.focusElement({ elementForFocus: n, event: e, contextStateRef: a });
    return;
  }
  const f = e.target, i = f.className.indexOf("k-checkbox") === -1 ? f : o.getClosestNavigatableElement(f), g = o.getNavigatableId(i), E = g == null ? void 0 : g.endsWith("column"), x = o.getNavigatableLevel(i), u = o.getClosestScope(i), v = t.current.navigationMatrix, I = e.metaKey || e.ctrlKey, m = F(t, v, g);
  if (x !== void 0 && u) {
    if (e.keyCode === l.enter) {
      const s = o.getNavigatableElement(i, { level: x + 1 });
      if (s) {
        o.focusElement({
          elementForFocus: s,
          event: e,
          contextStateRef: a,
          prevElement: i
        });
        return;
      } else {
        n = o.getFocusableElements(i)[0], o.focusElement({ elementForFocus: n, event: e, contextStateRef: a, prevElement: i });
        return;
      }
    }
    if (e.keyCode === l.home && m)
      if (I)
        D(
          {
            scope: u,
            navigationStateRef: t,
            contextStateRef: a
          },
          e
        );
      else {
        const s = w(t.current.navigationMatrix, m[0]);
        n = o.getActiveNavDataElement(u, s), o.focusElement({ elementForFocus: n, event: e, contextStateRef: a });
      }
    if (e.keyCode === l.end && m)
      if (I) {
        const s = L(t.current.navigationMatrix);
        n = o.getActiveNavDataElement(u, s), o.focusElement({ elementForFocus: n, event: e, contextStateRef: a });
      } else {
        const s = M(t.current.navigationMatrix, m[0]);
        n = o.getActiveNavDataElement(u, s), o.focusElement({ elementForFocus: n, event: e, contextStateRef: a });
      }
    if (e.keyCode === l.up || e.keyCode === l.down || e.keyCode === l.left || e.keyCode === l.right) {
      const s = e.keyCode === l.up || e.keyCode === l.left, d = e.keyCode === l.up || e.keyCode === l.down;
      if (m) {
        const [p, C] = m, [y, k] = d ? H(p, C, g, v, s) : U(p, C, g, v, s);
        y && (n = o.getActiveNavDataElement(u, y), o.focusElement({ elementForFocus: n, event: e, contextStateRef: a, prevElement: i }), t.current.prevNavigationIndexes = k);
      }
    }
    if (I && e.keyCode === l.left && E) {
      r && r({ focusElement: i, event: e, action: "reorderToLeft" }), e.preventDefault();
      return;
    }
    if (I && e.keyCode === l.right && E) {
      r && r({ focusElement: i, event: e, action: "reorderToRight" }), e.preventDefault();
      return;
    }
    if (e.keyCode === l.pageUp) {
      r && r({ focusElement: n, event: e, action: "moveToNextPage" }), e.preventDefault();
      return;
    }
    if (e.keyCode === l.pageDown) {
      r && r({ focusElement: n, event: e, action: "moveToPrevPage" }), e.preventDefault();
      return;
    }
    r && r({ focusElement: n, event: e });
  }
}, b = (e) => {
  const { navigationStateRef: c, scope: a } = e;
  if (!c.current || !a)
    return;
  const t = [], r = P(a), n = K(a), f = T(a) || { children: [] };
  if (!r || !n)
    return;
  const i = Array.from(r.children), g = Array.from(n.children);
  [...i, ...g, f].forEach((E, x) => {
    Array.from(E.children).forEach((u) => {
      const v = B(u);
      if (!v)
        return;
      const I = u.rowSpan || 1, m = u.colSpan || 1;
      let s;
      for (let d = x, p = x + I; d < p; d++) {
        if (t[d] || (t[d] = []), s === void 0) {
          const C = t[d].findIndex((y) => !y);
          s = C > -1 ? C : t[d].length;
        }
        t[d][s] = v || "";
      }
      for (let d = s + 1, p = s + m; d < p; d++)
        t[x][d] = v || "";
    });
  }), c.current.navigationMatrix = t.filter((E) => !!E), c.current.lastHeaderIndex = i.length - 1;
}, z = {
  onConstructor: R,
  onComponentDidMount: h,
  onGetSnapshotBeforeUpdate: O,
  onComponentDidUpdate: G,
  onFocus: V,
  onKeyDown: W,
  generateMatrix: b,
  focusFirstDataElement: D
};
export {
  z as tableKeyboardNavigation
};
