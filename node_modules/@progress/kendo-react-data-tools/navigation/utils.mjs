/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { FOCUSABLE_ELEMENTS as i, TABBABLE_ELEMENTS as g } from "@progress/kendo-react-common";
import { KEYBOARD_NAV_DATA_LEVEL as s, KEYBOARD_NAV_DATA_ID as f, KEYBOARD_NAV_DATA_SCOPE as I, KEYBOARD_NAV_DATA_HEADER as N, KEYBOARD_NAV_DATA_BODY as v, KEYBOARD_NAV_FILTER_COL_SUFFIX as b } from "./constants.mjs";
const _ = (e, t, r = "cell") => `${t}_${e}_${r}`, D = (e) => {
  if (e)
    return parseInt(e.getAttribute(s) || "", 10);
}, d = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(f);
  return t || void 0;
}, u = (e) => e ? !!e.getAttribute(f) : !1, x = (e, t = { level: 0 }) => e.querySelector(`[${s}='${t.level}']`), m = (e) => e && e.parentElement && e.parentElement.closest(`[${s}]`), A = (e, t) => e.querySelector(`[${f}='${t}']`), p = (e) => e && e.parentElement && e.parentElement.closest(`[${I}]`), $ = (e) => e.querySelector(`[${N}]`), y = (e) => e.querySelector(`[${v}]`), V = (e) => e.querySelector(".k-grid-norecords"), B = (e, t) => {
  const {
    scope: r,
    navigationStateRef: n,
    contextStateRef: l
  } = e;
  if (!n.current || !r)
    return;
  const o = R(n.current.navigationMatrix), c = A(r, o);
  E({ elementForFocus: c, contextStateRef: l, event: t });
}, C = (e, t = { focusable: !1 }) => {
  const r = t.focusable ? i : g;
  return Array.from(e.querySelectorAll(r.join(",")));
}, h = (e, t = { level: 0 }) => {
  if (!e)
    return [];
  const r = i.map((n) => n + `[${s}='${t.level}']`).join(",");
  return Array.from(e.querySelectorAll(r));
}, F = (e = { level: 0 }) => {
  const t = i.map(
    (r) => r + `[${s}='${e.level}']`
  ).join(",");
  return (r) => r.matches(t);
}, E = (e) => {
  const { elementForFocus: t, event: r, contextStateRef: n, prevElement: l } = e;
  if (n.current && t && t.focus) {
    r == null || r.preventDefault();
    const o = t.querySelector(".k-checkbox-wrap .k-checkbox");
    o && o.focus ? o.focus() : t.focus(), u(t) && (t.setAttribute("tabIndex", "0"), n.current.activeId = d(t)), l && u(l) && l.setAttribute("tabIndex", "-1");
  }
}, S = (e) => e.current ? e.current.idPrefix : "", L = (e, t, r, n, l) => {
  if (!r)
    return [];
  let o = e + (l ? -1 : 1);
  for (; o >= 0 && o < n.length; ) {
    const c = n[o][t];
    if (c !== r)
      return [c, [o, t]];
    o = o + (l ? -1 : 1);
  }
  return [];
}, O = (e, t, r, n, l) => {
  if (!r)
    return [];
  let o = t + (l ? -1 : 1);
  for (; o >= 0 && o < n[e].length; ) {
    const c = n[e][o];
    if (c !== r)
      return [c, [e, o]];
    o = o + (l ? -1 : 1);
  }
  return [];
}, a = (e, t) => {
  if (t) {
    for (let r = 0; r < e.length; r++)
      for (let n = 0; n < e[r].length; n++)
        if (e[r][n] === t)
          return [r, n];
  }
}, T = (e) => e.current ? e.current.navigationMatrix.length : 0, R = (e) => e.flat().find((t) => t.endsWith("cell")), Y = (e) => e.flat().reverse().find((t) => t.endsWith("cell")), k = (e, t) => e[t][0], j = (e, t) => Array.from(e[t]).reverse()[0], q = (e) => e ? `${e}${b}` : "", P = (e, t, r) => {
  let n;
  if (e.current && e.current.prevNavigationIndexes) {
    const [l, o] = e.current.prevNavigationIndexes;
    t[l][o] === r ? n = e.current.prevNavigationIndexes : n = a(t, r);
  } else
    n = a(t, r);
  return n;
}, H = {
  generateNavigatableId: _,
  getNavigatableId: d,
  getNavigatableLevel: D,
  getNavigatableElement: x,
  getClosestNavigatableElement: m,
  getActiveNavDataElement: A,
  getClosestScope: p,
  getHeaderElement: $,
  getBodyElement: y,
  getFocusableElements: C,
  getNavigatableElements: h,
  filterNavigatableElements: F,
  focusElement: E,
  getIdPrefix: S,
  isNavigatable: u,
  findNextIdByRowIndex: L,
  findNextIdByCellIndex: O,
  findId: a,
  getNextNavigationIndex: T,
  getFilterColumnId: q,
  focusFirstDataElement: B
};
export {
  F as filterNavigatableElements,
  a as findId,
  O as findNextIdByCellIndex,
  L as findNextIdByRowIndex,
  E as focusElement,
  B as focusFirstDataElement,
  _ as generateNavigatableId,
  A as getActiveNavDataElement,
  y as getBodyElement,
  m as getClosestNavigatableElement,
  p as getClosestScope,
  P as getCurrentIdIndexes,
  q as getFilterColumnId,
  R as getFirstDataCell,
  k as getFirstRowDataCell,
  C as getFocusableElements,
  $ as getHeaderElement,
  S as getIdPrefix,
  Y as getLastDataCell,
  j as getLastRowDataCell,
  x as getNavigatableElement,
  h as getNavigatableElements,
  d as getNavigatableId,
  D as getNavigatableLevel,
  T as getNextNavigationIndex,
  V as getNoRecordsElement,
  u as isNavigatable,
  H as tableKeyboardNavigationTools
};
