/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { BaseEvent } from '@progress/kendo-react-common';
import { ComponentType } from 'react';
import { CompositeFilterDescriptor } from '@progress/kendo-data-query';
import { DropDownListProps } from '@progress/kendo-react-dropdowns';
import { FilterDescriptor } from '@progress/kendo-data-query';
import { GroupDescriptor } from '@progress/kendo-data-query';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import PropTypes from 'prop-types';
import * as React_2 from 'react';
import { SortDescriptor } from '@progress/kendo-data-query';
import { SVGIcon } from '@progress/kendo-react-common';

/**
 * Represents the base object of the `onPageChange` event. It is usually used
 * in custom pager scenarios in cases when we don't need any of the events or the target.
 */
export declare interface BasePageChangeEvent {
    /**
     * The number of records that will be skipped.
     */
    skip: number;
    /**
     * The number of records that will be taken.
     */
    take: number;
    /**
     * A React Synthetic Event.
     */
    syntheticEvent?: React_2.SyntheticEvent<any>;
    /**
     * A native DOM event.
     */
    nativeEvent?: any;
    /**
     * A target change event.
     */
    targetEvent?: PagerTargetEvent;
}

/**
 * The BooleanFilter component used for editing boolean value of FilterDescriptor object.
 */
export declare class BooleanFilter extends React_2.Component<BooleanFilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        filter: PropTypes.Validator<object>;
        onFilterChange: PropTypes.Validator<(...args: any[]) => any>;
        data: PropTypes.Requireable<(PropTypes.InferProps<{
            text: PropTypes.Requireable<string>;
            value: PropTypes.Requireable<any>;
        }> | null | undefined)[]>;
        ariaLabel: PropTypes.Requireable<string>;
        defaultItem: PropTypes.Requireable<any>;
    };
    private data;
    /**
     * @hidden
     */
    render(): JSX_2.Element;
}

/**
 * @hidden
 */
export declare class BooleanFilterCell extends BooleanFilterCell_base {
}

declare const BooleanFilterCell_base: React_2.ComponentClass<FilterComponentProps, any>;

/**
 * The props of the BooleanFilter component.
 */
export declare interface BooleanFilterProps extends TextFilterProps {
    /**
     * A collection of text-value pairs passed to the BooleanFilter DropDownList.
     * Defaults to [ { text: 'True', value: true }, { text: 'False', value: false } ]
     */
    data?: Array<{
        text: string;
        value: any;
    }>;
    /**
     * The defaultItem passed to the BooleanFilter DropDownList.
     */
    defaultItem?: any;
}

export declare interface CellProps {
    /**
     * @hidden
     */
    id: string;
    /**
     * The index to be applied to the `aria-colindex` attribute.
     */
    ariaColumnIndex: number;
    /**
     * Indicates if the cell is selected.
     */
    isSelected: boolean;
    /**
     * The expanded value of the cell.
     */
    expanded?: boolean;
    /**
     * The custom CSS classes of the cells.
     */
    className?: string;
    /**
     * The styles for the cell.
     */
    style?: React_2.CSSProperties;
    /**
     * The field to which the cell is bound.
     */
    field?: string;
    /**
     * The data item which corresponds to the current row.
     */
    dataItem: any;
    /**
     * The format that is applied to the value before the value is displayed.
     * Takes the `{0:format}` form where `format` is a standard number format, a custom number format,
     * a standard date format, or a custom date format. For more information on the supported date and number formats,
     * refer to the [kendo-intl](https://github.com/telerik/kendo-intl/blob/develop/docs/index.md) documentation.
     */
    format?: string;
    /**
     * The column span of the cell.
     */
    colSpan?: number;
    /**
     * The event that is fired when the cell is selected.
     */
    selectionChange?: (event: {
        syntheticEvent: React_2.SyntheticEvent<any>;
    }) => void;
    /**
     * The event that is fired when the cell value is changed.
     */
    onChange?: (event: {
        dataItem: any;
        syntheticEvent: React_2.SyntheticEvent<any>;
        field?: string;
        value?: any;
    }) => void;
    /**
     * A function for overriding the default rendering of the cell.
     */
    render?: (defaultRendering: React_2.ReactElement<HTMLTableCellElement> | null, props: CellProps) => React_2.ReactElement<HTMLTableCellElement> | null;
}

/**
 * The possible values of the  `type` property.
 */
export declare enum ClipboardActionType {
    copy = "copy",
    cut = "cut",
    paste = "paste"
}

/**
 * Represents the object that is returned form the `populateClipboardData` function.
 */
export declare interface ClipboardData {
    /**
     * A collection of the ClipboardItem that are selected.
     */
    copiedItems: ClipboardItem_2[];
    /**
     * A collection of the ClipboardItem that are pasted.
     */
    pastedItems: ClipboardItem_2[];
    /**
     * When the action is `copy` or `cut` - the Grid data, copied to the clipboard, in Excel-compatible format.
     * When the action is `paste` - the current clipboard data, available in the original DOM event.
     */
    clipboardData: string;
}

/**
 * Represents the object of the `onClipboardData` event.
 */
export declare interface ClipboardDataEvent {
    /**
     * Represents the type of the clipboard action.
     */
    type: ClipboardActionType;
    /**
     * Represents the native [ClipboardEvent]({% slug api_grid_gridcellssettings %})
     */
    nativeEvent?: ClipboardEvent;
    /**
     * All the Grid columns. It takes value of type of [ColumnBaseProps]({% slug api_data-tools_columnbaseprops %})&lt;[CellProps]({% slug api_data-tools_cellprops %})&gt;[]
     */
    columns: ColumnBaseProps[];
    /**
     * Passes the clipboard prop copyHeaders value in the clipboard action.
     */
    copyHeaders?: boolean;
    /**
     * Sets the cell delimiter used when manipulating the clipboard data Defaults to `\t`.
     */
    cellDelimiter?: string;
    /**
     * Sets the row delimiter used when manipulating the clipboard data Defaults to `\r\n`.
     */
    newLineDelimiter?: string;
    /**
     * Passes the dataItemKey prop in the clipboard action.
     */
    dataItemKey: string;
}

/**
 * Represents the aria that is copied - the dataItem and the fields.
 */
declare interface ClipboardItem_2 {
    /**
     * Represents the dataItem used in the clipboard action.
     */
    dataItem: any;
    /**
     * Represents the fields used in the clipboard action.
     */
    fields: string[];
}
export { ClipboardItem_2 as ClipboardItem }

/**
 * @hidden
 */
export declare class ClipboardService {
    private clipboardEvent;
    constructor(ClipboardEventHandler: (clipboardType: ClipboardActionType, event: ClipboardEvent) => void);
    private copyHandler;
    private cutHandler;
    private pasteHandler;
    addEventListeners: (document: Document | undefined) => void;
    removeEventListeners: (document: Document | undefined) => void;
}

/**
 * Represents settings that can be added to the clipboard behavior.
 */
export declare interface ClipboardSettings {
    /**
     * Determines whether column titles or field names will be included in the generated data
     * during the `copy` and `cut` actions.
     * Defaults to `false`.
     */
    copyHeaders: boolean;
    /**
     * Determines what is the delimiter used to separate the cells.
     * Defaults to `\t`.
     */
    cellDelimiter?: string;
    /**
     * Determines what is the delimiter used to separate the rows.
     * Defaults to `'\r\n'`.
     */
    newLineDelimiter?: string;
}

/** @hidden */
export declare const closestTagName: (target: HTMLElement | null, tagName: 'TD' | 'TR' | 'TABLE') => HTMLElement | null;

export declare interface ColumnBaseProps<CellProps = CellProps> {
    /**
     * The field to which the column is bound.
     */
    field?: string;
    /**
     * The title of the column.
     */
    title?: string;
    /**
     * Allows the column headers to be clicked and the `sortChange` event emitted.
     * You have to handle the `sortChange` event yourself and sort the data.
     * Defaults to `true`.
     */
    sortable?: boolean | ColumnSortSettings;
    /**
     * The width of the column (in pixels).
     */
    width?: string | number;
    /**
     * Defines if the header selection checkbox is checked.
     */
    headerSelectionValue?: boolean;
    /**
     * The format that is applied to the value before it is displayed.
     * Takes the `{0:format}` form where `format` is a standard number format, a custom number format,
     * a standard date format, or a custom date format. For more information on the supported date and number formats,
     * refer to the [kendo-intl](https://github.com/telerik/kendo-intl/blob/develop/docs/index.md) documentation.
     */
    format?: string;
    /**
     * Sets the custom CSS classes to the column header cell.
     */
    headerClassName?: string;
    /**
     * Sets the custom CSS classes to the column cells.
     */
    className?: string;
    /**
     * Indicates whether the column is resizable.
     */
    resizable?: boolean;
    /**
     * Indicates whether the column is reorderable.
     */
    reorderable?: boolean;
    /**
     * The width of the column (in pixels) below which the user is not able to resize the column through the UI. Defaults to `10`.
     */
    minResizableWidth?: number;
    /**
     * Determinates the position of the column.
     * Columns with smaller `orderIndex` will appear before columns with bigger `orderIndex`.
     * Defaults to `0`.
     */
    orderIndex?: number;
    /**
     * The column identifier used to distinguish columns for example in multi column header scenarios with resize and keyboard navigation.
     * Also used for unique key for rendering the component cells.
     * If not set, the component will generate unique `id` automatically.
     */
    id?: string;
    /**
     * Defines the component that will be rendered as a cell.
     * If not set, a `Cell` will be rendered by default.
     */
    cell?: ComponentType<CellProps>;
    /**
     * @hidden
     */
    navigatable?: boolean;
    /**
     * @hidden
     */
    locked?: boolean;
}

/**
 * @hidden
 */
export declare const ColumnDefaultProps: {
    filterable: boolean;
    editable: boolean;
    sortable: boolean;
    resizable: boolean;
    reorderable: boolean;
    groupable: boolean;
};

/**
 * @hidden
 */
declare interface ColumnDraggableProps {
    pressHandler?: (draggableEvent: any, element: HTMLTableRowElement | HTMLDivElement) => void;
    dragHandler?: (draggableEvent: any, element: HTMLTableRowElement | HTMLDivElement) => void;
    releaseHandler?: (draggableEvent: any) => void;
    ariaRowIndex?: number;
    children?: React_2.ReactNode;
}

/**
 * The `ColumnMenuBooleanColumn` component. Use it for `boolean` type columns.
 */
export declare const ColumnMenuBooleanColumn: React_2.FunctionComponent<ColumnMenuProps>;

export declare const ColumnMenuBooleanFilter: React_2.FunctionComponent<ColumnMenuFilterProps>;

/**
 * The `ColumnMenuDateColumn` component. Use it for `Date` type columns.
 */
export declare const ColumnMenuDateColumn: React_2.FunctionComponent<ColumnMenuProps>;

export declare const ColumnMenuDateFilter: React_2.FunctionComponent<ColumnMenuFilterProps>;

/**
 * @hidden
 */
export declare const ColumnMenuFilterForm: React_2.FunctionComponent<ColumnMenuFormProps>;

export declare const ColumnMenuFilterLogic: React_2.FunctionComponent<DropDownListProps>;

export declare interface ColumnMenuFilterProps {
    filter: FilterDescriptor;
    onFilterChange: (event: React_2.SyntheticEvent<any>, nextFilter: FilterDescriptor, prevFilter: FilterDescriptor) => void;
    operators?: {
        text: string;
        operator: string;
    }[];
    initialFilter?: FilterDescriptor;
    input?: React_2.ComponentType<{
        value: any;
        onChange: any;
    }>;
}

export declare const ColumnMenuForm: React_2.FunctionComponent<ColumnMenuFormProps>;

export declare interface ColumnMenuFormProps {
    show?: boolean;
    onSubmit?: React_2.FormEventHandler<HTMLFormElement>;
    onReset?: React_2.FormEventHandler<HTMLFormElement>;
    actions?: React_2.ReactNode;
    children?: React_2.ReactNode;
}

export declare const ColumnMenuItem: React_2.FunctionComponent<ColumnMenuItemProps>;

export declare interface ColumnMenuItemProps {
    onClick?: (event: React_2.MouseEvent<HTMLDivElement>) => void;
    selected?: boolean;
    disabled?: boolean;
    iconClass?: string;
    svgIcon?: SVGIcon;
    title: string;
}

/**
 * The `ColumnMenuNumericColumn` component. Use it for `number` type columns.
 */
export declare const ColumnMenuNumericColumn: React_2.FunctionComponent<ColumnMenuProps>;

export declare const ColumnMenuNumericFilter: React_2.FunctionComponent<ColumnMenuFilterProps>;

/**
 * Represents the operators for the ColumnMenuTextFilter, ColumnMenuNumericFilter,
 * ColumnMenuDateFilter and ColumnMenuBooleanFilter components.
 *
 * The text field of each operator object will be resolved according to the
 * [localization messages]({% slug globalization_datatools %}#toc-messages).
 */
export declare class ColumnMenuOperators {
    /**
     * An array containing the operators for the ColumnMenuTextFilter component.
     *
     * The operators are:
     *
     * - { text: 'columnMenu.filterContainsOperator', operator: 'contains' }
     * - { text: 'columnMenu.filterNotContainsOperator', operator: 'doesnotcontain' }
     * - { text: 'columnMenu.filterEqOperator', operator: 'eq' }
     * - { text: 'columnMenu.filterNotEqOperator', operator: 'neq' }
     * - { text: 'columnMenu.filterStartsWithOperator', operator: 'startswith' }
     * - { text: 'columnMenu.filterEndsWithOperator', operator: 'endswith' }
     * - { text: 'columnMenu.filterIsNullOperator', operator: 'isnull' }
     * - { text: 'columnMenu.filterIsNotNullOperator', operator: 'isnotnull' }
     * - { text: 'columnMenu.filterIsEmptyOperator', operator: 'isempty' }
     * - { text: 'columnMenu.filterIsNotEmptyOperator', operator: 'isnotempty' }
     */
    static get text(): FilterOperator[];
    /**
     * An array containing the operators for the ColumnMenuNumericFilter component.
     *
     * The operators are:
     *
     * - { text: 'columnMenu.filterEqOperator', operator: 'eq' }
     * - { text: 'columnMenu.filterNotEqOperator', operator: 'neq' }
     * - { text: 'columnMenu.filterGteOperator', operator: 'gte' }
     * - { text: 'columnMenu.filterGtOperator', operator: 'gt' }
     * - { text: 'columnMenu.filterLteOperator', operator: 'lte' }
     * - { text: 'columnMenu.filterLtOperator', operator: 'lt' }
     * - { text: 'columnMenu.filterIsNullOperator', operator: 'isnull' }
     * - { text: 'columnMenu.filterIsNotNullOperator', operator: 'isnotnull' }
     */
    static get numeric(): FilterOperator[];
    /**
     * An array containing the operators for the ColumnMenuDateFilter component.
     *
     * The operators are:
     *
     * - { text: 'columnMenu.filterEqOperator', operator: 'eq' }
     * - { text: 'columnMenu.filterNotEqOperator', operator: 'neq' }
     * - { text: 'columnMenu.filterAfterOrEqualOperator', operator: 'gte' }
     * - { text: 'columnMenu.filterAfterOperator', operator: 'gt' }
     * - { text: 'columnMenu.filterBeforeOperator', operator: 'lt' }
     * - { text: 'columnMenu.filterBeforeOrEqualOperator', operator: 'lte' }
     * - { text: 'columnMenu.filterIsNullOperator', operator: 'isnull' }
     * - { text: 'columnMenu.filterIsNotNullOperator', operator: 'isnotnull' }
     */
    static get date(): FilterOperator[];
    /**
     * An array containing the operators for the ColumnMenuBooleanFilter component.
     *
     * The operators are:
     *
     * - { text: 'columnMenu.filterIsTrue', operator: '' }
     */
    static get boolean(): FilterOperator[];
}

/**
 * The props of the ColumnMenu component.
 */
export declare interface ColumnMenuProps {
    /**
     * The descriptors by which the data is sorted.
     */
    sort?: SortDescriptor[];
    /**
     * Fires when the sorting of the ColumnMenu is changed.
     */
    onSortChange?: (event: React_2.SyntheticEvent<any>, sort: SortDescriptor[], field: string) => void;
    /**
     * The descriptors by which the data is filtered.
     */
    filter?: CompositeFilterDescriptor[];
    /**
     * Fires when the ColumnMenu filter is changed.
     */
    onFilterChange?: (event: React_2.SyntheticEvent<any>, filter: CompositeFilterDescriptor[], field: string) => void;
    /**
     * The field to which the ColumnMenu is bound.
     */
    field?: string;
    /**
     * If set to `true`, a button for sorting in `asc` direction will be rendered.
     */
    sortAsc?: boolean;
    /**
     * If set to `true`, a button for sorting in `desc` direction will be rendered.
     */
    sortDesc?: boolean;
    /**
     * Defines the filtering UI and accepts an array with components.
     */
    filterContent?: any[];
    /**
     * Defines the initial expand state of the filters.
     * Defaults to `false`.
     */
    expandFilters?: boolean;
    /**
     * A function that returns the initial filter descriptor base on the ColumnMenu field.
     * Use it to customize the initial values of the filtering components.
     */
    initialFilter?: (field: string) => CompositeFilterDescriptor;
    /**
     * Fires when the ColumnMenu items are about to be rendered. Use it to add or remove menu items.
     * The `defaultRendering` is an array with the sorting and filtering components.
     * `props` contains the column's field and the closeMenu function which closes the ColumnMenu.
     */
    itemsRender?: (defaultRendering: (React_2.ReactElement<HTMLDivElement> | null)[], props: {
        field?: string;
        closeMenu: () => void;
    }) => React_2.ReactNode;
    /**
     * Fires when the ColumnMenu is about to be rendered. Use it to override the default rendering of the ColumnMenu.
     * The defaultRendering is an array with the button `React.ReactElement<HTMLSpanElement>` and popup `React.ReactElement<PopupProps>` components.
     */
    render?: (defaultRendering: React_2.ReactElement<any>[]) => React_2.ReactNode;
}

/**
 * The `ColumnMenuTextColumn` component. Use it for `string` type columns.
 */
export declare const ColumnMenuTextColumn: React_2.FunctionComponent<ColumnMenuProps>;

export declare const ColumnMenuTextFilter: React_2.FunctionComponent<ColumnMenuFilterProps>;

/**
 * @hidden
 */
export declare class ColumnResize<C = CellProps, H = HeaderCellProps, F = FilterCellProps> {
    /**
     * The main `colgroup` of the Grid.
     */
    colGroupMain: any | null;
    /**
     * The header `colgroup` of the Grid (if any).
     */
    colGroupHeader: any | null;
    /**
     * The footer `colgroup` of the Grid (if any).
     */
    colGroupFooter: any | null;
    columns: ExtendedColumnProps<C, H, F>[];
    /**
     * The settings for resizing the Grid.
     */
    resizable: boolean;
    onResize: (index: number, newWidth: number, oldWidth: number, originalEvent: any, end: boolean) => void;
    private isRtl;
    constructor(triggerResize: (index: number, newWidth: number, oldWidth: number, originalEvent: any, end: boolean) => void);
    setIsRtl: (isRtl: boolean) => void;
    dragHandler(event: any, column: ExtendedColumnProps<C, H, F>, dragCue: HTMLSpanElement, end: boolean): void;
    private setWidths;
    private updateColElements;
    private setColWidth;
}

/**
 * @hidden
 */
export declare class ColumnResizer extends React_2.Component<ColumnResizerResizerProps, {}> {
    private draggable;
    private isDragged;
    /**
     * @hidden
     */
    onDrag: (data: any) => void;
    /**
     * @hidden
     */
    onRelease: (data: any) => void;
    /**
     * @hidden
     */
    onDoubleClick: (event: React_2.MouseEvent<HTMLSpanElement, MouseEvent>) => void;
    render(): JSX_2.Element;
}

/**
 * @hidden
 */
declare interface ColumnResizerResizerProps {
    resize: (event: any, dragCue: HTMLSpanElement, end: boolean) => void;
    autofit?: (event: React_2.MouseEvent<HTMLSpanElement, MouseEvent>, dragCue: HTMLSpanElement) => void;
}

/**
 * The settings for sorting the columns of the component.
 */
export declare interface ColumnSortSettings {
    /**
     * Enables the removal of the column sorting functionality.
     */
    allowUnsort?: boolean;
}

/**
 * @hidden
 */
export declare class CommonDragLogic<C = CellProps, H = HeaderCellProps, F = FilterCellProps> {
    columns: ExtendedColumnProps<C, H, F>[];
    reorderable: boolean;
    groupable: boolean;
    private startColumn;
    private startGroup;
    private currentColumn;
    private currentGroup;
    private columnReorder;
    private groupReorder;
    private columnToGroup;
    private dropElementClue;
    private dragElementClue;
    private groupPanelDivElement;
    constructor(columnReorder: handler, groupReorder: handler, columnToGroup: handler);
    refGroupPanelDiv: (e: HTMLDivElement | null) => void;
    refDropElementClue: (e: DropClue | null) => void;
    refDragElementClue: (e: DragClue | null) => void;
    pressHandler: (event: any, element: HTMLTableRowElement | HTMLDivElement) => void;
    dragHandler: (event: any, element: HTMLTableRowElement | HTMLDivElement) => void;
    releaseHandler: (event: any) => void;
    private getColumnIndex;
    private getGroupIndex;
    private isValid;
    private updateDragElementClue;
    private updateDropElementClue;
}

/**
 * Creates a tree from the passed dataset.
 *
 * @param {object[]} dataset - The source dataset of data items.
 * @param {(item: object) => any} getId - A function which will return the id of the data item.
 * @param {(item: object) => any} getParentId - A function which will return the data item id of its parent data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {object[]} - A collection of the generated data items that are structured in a tree.
 */
export declare const createDataTree: (dataset: any[], getId: (item: any) => any, getParentId: (item: any) => any, subItemsField: string) => any[];

/**
 * @hidden
 */
export declare const createFilterComponent: (settings: FilterComponentSettings) => React_2.ComponentClass<FilterComponentProps, any>;

/**
 * @hidden
 */
declare interface DataItemWrapper {
    dataItem: any;
    level: number[];
    height: number;
    offsetTop: number;
    levelCount: number;
}

/**
 * The DateFilter component used for editing date value of FilterDescriptor object.
 */
export declare class DateFilter extends React_2.Component<DateFilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        filter: PropTypes.Validator<object>;
        onFilterChange: PropTypes.Validator<(...args: any[]) => any>;
        ariaLabel: PropTypes.Requireable<string>;
    };
    /**
     * @hidden
     */
    render(): JSX_2.Element;
    private onChange;
}

/**
 * @hidden
 */
export declare class DateFilterCell extends DateFilterCell_base {
}

declare const DateFilterCell_base: React_2.ComponentClass<FilterComponentProps, any>;

/**
 * The props of the DateFilter component.
 */
export declare interface DateFilterProps extends TextFilterProps {
}

/**
 * @hidden
 */
export declare class DragClue extends React_2.PureComponent<any, DragClueState> {
    private elementRef;
    readonly state: DragClueState;
    hiddenElementRef: React_2.RefObject<HTMLDivElement>;
    get element(): HTMLDivElement | null;
    constructor(props: any);
    render(): JSX_2.Element;
}

/**
 * @hidden
 */
declare interface DragClueState {
    visible: boolean;
    top: number;
    left: number;
    innerText: string;
    status: 'k-i-cancel' | 'k-i-plus';
}

/**
 * @hidden
 */
export declare class DropClue extends React_2.PureComponent<any, DropClueState> {
    readonly state: DropClueState;
    hiddenElementRef: React_2.RefObject<HTMLDivElement>;
    constructor(props: any);
    render(): JSX_2.Element;
}

/**
 * @hidden
 */
declare interface DropClueState {
    visible: boolean;
    top: number;
    left: number;
    height: number;
}

/**
 * The EnumFilter component used for editing the value of FilterDescriptor object.
 * It renders a DropDownList and allows you to choose a value from the predefined list.
 */
export declare class EnumFilter extends React_2.Component<EnumFilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        filter: PropTypes.Validator<object>;
        onFilterChange: PropTypes.Validator<(...args: any[]) => any>;
        data: PropTypes.Requireable<(PropTypes.InferProps<{
            text: PropTypes.Requireable<string>;
            value: PropTypes.Requireable<any>;
        }> | null | undefined)[]>;
        defaultItem: PropTypes.Requireable<any>;
        ariaLabel: PropTypes.Requireable<string>;
    };
    /**
     * @hidden
     */
    render(): JSX_2.Element;
    private onChange;
}

/**
 * The props of the EnumFilter component.
 */
export declare interface EnumFilterProps extends TextFilterProps {
    /**
     * A collection of text-value pairs passed to the EnumFilter DropDownList.
     */
    data?: Array<{
        text: string;
        value: any;
    }>;
    /**
     * The defaultItem passed to the EnumFilter DropDownList.
     */
    defaultItem?: any;
}

/**
 * @hidden
 */
export declare class Expression extends React_2.Component<ExpressionProps> {
    static propTypes: {
        filter: PropTypes.Validator<object>;
        fields: PropTypes.Validator<any[]>;
        ariaLabel: PropTypes.Requireable<string>;
        onChange: PropTypes.Validator<(...args: any[]) => any>;
        onRemove: PropTypes.Validator<(...args: any[]) => any>;
    };
    render(): JSX_2.Element;
    private onFieldChange;
    private onOperatorChange;
    private onInputChange;
    private triggerOnFilterChange;
    private onFilterRemove;
}

/**
 * @hidden
 */
export declare interface ExpressionChangeEvent extends BaseEvent<Expression> {
    prevFilter: FilterDescriptor;
    nextFilter: FilterDescriptor;
}

/**
 * @hidden
 */
export declare interface ExpressionProps {
    filter: FilterDescriptor;
    fields: Array<FieldSettings>;
    ariaLabel?: string;
    onChange: (event: ExpressionChangeEvent) => void;
    onRemove: (event: ExpressionRemoveEvent) => void;
}

/**
 * @hidden
 */
export declare interface ExpressionRemoveEvent extends BaseEvent<Expression> {
    filter: FilterDescriptor;
}

/**
 * Similar to the `Object.assign` function. Additionally, creates a new array for the subitems.
 *
 * @param {object} item - The source data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {object} propsToExtend - The props with which the source data item will be extended.
 * @returns {object} - The target data item.
 */
export declare const extendDataItem: (item: any, subItemsField: string, propsToExtend?: any) => any;

/**
 * @hidden
 */
export declare interface ExtendedColumnProps<CellProps = CellProps, HeaderCellProps = HeaderCellProps, FilterCellProps = FilterCellProps> extends TreeColumnBaseProps<CellProps, HeaderCellProps, FilterCellProps> {
    declarationIndex: number;
    parentIndex: number;
    colSpan: number;
    rowSpan: number;
    depth: number;
    kFirst?: boolean;
    index: number;
    children: ExtendedColumnProps<CellProps, HeaderCellProps, FilterCellProps>[];
    left: number;
    right: number;
    rightBorder: boolean;
    groupable: boolean;
    ariaColumnIndex: number;
    isAccessible: boolean;
}

/**
 * The FieldSettings object.
 */
export declare interface FieldSettings {
    /**
     * The field name.
     */
    name: string;
    /**
     * The field label, which will be shown in the fields DropDownList.
     */
    label: string;
    /**
     * The filter editor component. Could be any of the built-in TextFilter, NumericFilter, DateFilter, BooleanFilter or a custom component.
     */
    filter: any;
    /**
     * The collection of operators which will be passed to the operators DropDownList.
     */
    operators: Array<FilterOperator>;
    /**
     * Specifies the smallest value that can be entered.
     */
    min?: number;
    /**
     * Specifies the greatest value that can be entered.
     */
    max?: number;
}

/**
 * Represents the [KendoReact Filter component]({% slug overview_filter %}).
 */
export declare class Filter extends React_2.Component<FilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        className: PropTypes.Requireable<string>;
        style: PropTypes.Requireable<object>;
        fields: (props: FilterProps, propName: string) => Error | null;
        ariaLabelGroup: PropTypes.Requireable<string>;
        ariaLabelExpression: PropTypes.Requireable<string>;
        value: PropTypes.Validator<object>;
        onChange: PropTypes.Validator<(...args: any[]) => any>;
    };
    constructor(props: FilterProps);
    /**
     * @hidden
     */
    render(): JSX_2.Element;
    private onFilterChange;
    private onGroupRemove;
}

/**
 * @hidden
 */
export declare const FILTER_ROW_CLASS = "k-table-row k-filter-row";

/**
 * Filters the provided data tree according to the specified `Array<FilterDescriptor|CompositeFilterDescriptor>`.
 *
 * @param {T[]} data - The data that will be filtered.
 * @param {FilterDescriptor[]|CompositeFilterDescriptor[]} descriptors - The filter criteria that will be applied.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The filtered data.
 */
export declare function filterBy(data: any[], descriptors: FilterDescriptor[] | CompositeFilterDescriptor[], subItemsField: string): any[];

/**
 * @hidden
 */
export declare interface FilterCellProps {
    /**
     * The column field in which the cell is located.
     */
    field?: string;
    /**
     * The function that will be called if the cell needs to notify its parent TreeList about a change.
     */
    onFilterChange?: (event: {
        filter: Array<FilterDescriptor>;
        field: string;
        syntheticEvent: React.SyntheticEvent<any>;
    }) => void;
    /**
     * The collection of `FilterDescriptor` objects that is passed by the TreeList component.
     */
    filter?: FilterDescriptor[];
    /**
     * @hidden
     */
    components?: {
        DatePicker?: any;
        DropDownList?: any;
        Input?: any;
        NumericTextBox?: any;
    };
    /**
     * @hidden
     */
    clearButtonTitle?: string;
}

/**
 * The FilterChangeEvent object.
 */
export declare interface FilterChangeEvent extends BaseEvent<Filter> {
    /**
     * The changed composite filter descriptor.
     */
    filter: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
export declare interface FilterComponentProps extends FilterCellProps {
    /**
     * The list of the operators.
     */
    operators?: FilterOperator[];
    /**
     * The accessible label of the component.
     */
    ariaLabel?: string;
    /**
     * @hidden
     */
    min?: number;
    /**
     * @hidden
     */
    max?: number;
}

/**
 * @hidden
 */
export declare interface FilterComponentSettings {
    inputComponent: (props: any) => React_2.ReactNode;
    operatorComponent: (props: any, cellProps: FilterComponentProps) => React_2.ReactNode;
    emptyFilter: FilterDescriptor;
    operators?: FilterOperator[];
}

/**
 * A filter operator object.
 */
export declare interface FilterOperator {
    /**
     * The label of the operator.
     */
    text: string;
    /**
     * The operator value.
     */
    operator: any;
}

/**
 * The props of the Filter component.
 */
export declare interface FilterProps {
    /**
     * Sets additional classes to the Filter.
     */
    className?: string;
    /**
     * The styles that are applied to the Filter.
     */
    style?: React_2.CSSProperties;
    /**
     * The fields settings of the Filter.
     */
    fields: Array<FieldSettings>;
    /**
     * The composite filter descriptor value.
     */
    value: CompositeFilterDescriptor;
    /**
     * Represents the aria-label prop of the Filter's container component.
     */
    ariaLabel?: string;
    /**
     * Represents the aria-label prop of the Filter's underlying Group component.
     */
    ariaLabelGroup?: string;
    /**
     * Represents the aria-label prop of the Filter's underlying Expression component.
     */
    ariaLabelExpression?: string;
    /**
     * The Filter onChange event.
     */
    onChange: (event: FilterChangeEvent) => void;
    /**
     * The initial composite filter descriptor which will be used when a new group is created.
     */
    defaultGroupFilter?: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
export declare const FilterRow: (props: FilterRowProps) => JSX_2.Element;

/**
 * @hidden
 */
export declare interface FilterRowProps {
    columns: ExtendedColumnProps[];
    filter?: FilterDescriptor[];
    filterChange: (event: {
        filter: FilterDescriptor[];
        field: string;
        syntheticEvent: React_2.SyntheticEvent<any>;
    }) => void;
    sort?: SortDescriptor[];
    ariaRowIndex?: number;
}

/**
 * @hidden
 */
export declare function flatData(data: any[], getChildren: (dataItem: any) => any[], itemMap: (item: any) => any): DataItemWrapper[];

/** @hidden */
export declare const getColumnIndex: (element: HTMLTableCellElement) => number | undefined;

/**
 * Get all group ids from the data.
 *
 * @param {{data: any[]}} options - The options to be processed.
 * @returns {string[]} - Collection of all group ids from the data.
 */
export declare const getGroupIds: (options: {
    data: any;
}) => string[];

/**
 * @hidden
 */
export declare function getIndex(event: any, parent: HTMLTableRowElement | HTMLDivElement | null): number;

/**
 * Returns the data item path in the tree based on the level parameter.
 *
 * @param {any[]} tree - The data tree.
 * @param {number[]} level - The level of the target tree item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {any[]} - The path of the data item.
 */
export declare const getItemPath: (tree: any[], level: number[], subItemsField?: string) => any[];

/** @hidden */
export declare const getOffset: (offsetParent: any) => any;

/** @hidden */
export declare const getRowIndex: (element: HTMLTableRowElement) => number | undefined;

/**
 * Get selected state from the component selection event.
 *
 * @param {{event: TableSelectionChangeEvent, selectedState:  {[id: string]: boolean | number[]}, dataItemKey: string}} options
 * @returns {{[id: string]: boolean | number[]}} - The new selected state.
 */
export declare const getSelectedState: (options: {
    event: TableSelectionChangeEvent<any>;
    selectedState: {
        [id: string]: boolean | number[];
    };
    dataItemKey: string;
}) => {
    [id: string]: boolean | number[];
};

/**
 * Get selected state from the component KeyDown event.
 *
 * @param {{event: TableKeyDownEvent, selectedState:  {[id: string]: boolean | number[]}, dataItemKey: string}} options
 * @returns {{[id: string]: boolean | number[]}} - The new selected state.
 */
export declare const getSelectedStateFromKeyDown: (options: {
    event: TableKeyDownEvent<any>;
    selectedState: {
        [id: string]: boolean | number[];
    };
    dataItemKey: string;
}) => {
    [id: string]: boolean | number[];
};

/** @hidden */
export declare const getSelectionOptions: (selectable?: TableSelectableSettings) => {
    enabled: boolean;
    drag: boolean;
    mode: TableSelectableMode;
    cell: boolean;
};

/**
 * @hidden
 */
export declare class Group extends React_2.Component<GroupProps> {
    static propTypes: {
        filter: PropTypes.Validator<object>;
        fields: PropTypes.Validator<any[]>;
        ariaLabel: PropTypes.Requireable<string>;
        ariaLabelExpression: PropTypes.Requireable<string>;
        onChange: PropTypes.Validator<(...args: any[]) => any>;
        onRemove: PropTypes.Validator<(...args: any[]) => any>;
        defaultGroupFilter: PropTypes.Validator<object>;
    };
    render(): JSX_2.Element;
    private onGroupRemove;
    private onAddExpression;
    private onAddGroup;
    private onLogicAnd;
    private onLogicOr;
    private changeLogic;
    private replaceFilter;
    private onChange;
    private onRemove;
}

/**
 * @hidden
 */
export declare interface GroupChangeEvent extends BaseEvent<Group> {
    prevFilter: CompositeFilterDescriptor;
    nextFilter: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
export declare interface GroupProps {
    filter: CompositeFilterDescriptor;
    fields: Array<FieldSettings>;
    ariaLabel?: string;
    ariaLabelExpression?: string;
    onChange: (event: GroupChangeEvent) => void;
    onRemove: (event: GroupRemoveEvent) => void;
    defaultGroupFilter: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
export declare interface GroupRemoveEvent extends BaseEvent<Group> {
    filter: CompositeFilterDescriptor;
}

/**
 * @hidden
 */
declare type handler = (prevIndex: number, nextIndex: number, nativeEvent: any) => void;

/**
 * @hidden
 */
export declare class Header extends React_2.Component<HeaderProps> {
    private element;
    componentDidMount(): void;
    render(): JSX_2.Element;
}

/**
 * @hidden
 */
export declare function HeaderCell(props: HeaderCellProps): JSX_2.Element;

/**
 * @hidden
 */
export declare interface HeaderCellBaseProps {
    /**
     * The column field in which the cell is located.
     */
    field?: string;
    /**
     * The title of the column in which the cell is located.
     */
    title?: string;
    /**
     * The `click` event handler of the cell.
     */
    onClick?: any;
    /**
     * The `selectionChange` event handler of the cell.
     */
    selectionChange: any;
    /**
     * The `selectionValue` event handler of the column in which the cell is located.
     */
    selectionValue: any;
    /**
     * A function for overriding the default rendering of the header cell.
     */
    render?: (defaultRendering: React_2.ReactNode | null, props: HeaderCellBaseProps) => React_2.ReactNode;
    /**
     * The current sort icons.
     */
    children: React_2.ReactNode;
}

/**
 * @hidden
 */
export declare interface HeaderCellProps extends HeaderCellBaseProps {
    /**
     * A function for overriding the default rendering of the header cell.
     */
    render?: (defaultRendering: React_2.ReactNode | null, props: HeaderCellProps) => React_2.ReactNode;
}

/**
 * @hidden
 */
export declare interface HeaderProps {
    headerRow: React_2.ReactElement<any>;
    filterRow?: React_2.ReactElement<any>;
    columnResize?: ColumnResize;
}

/**
 * @hidden
 */
export declare class HeaderRow<C = CellProps, H = HeaderCellProps, F = FilterCellProps> extends React_2.Component<HeaderRowProps<C, H, F>, {}> {
    cellClick: (e: React_2.MouseEvent<HTMLSpanElement> | React_2.KeyboardEvent<HTMLElement>, column: TreeColumnBaseProps<C, H, F>) => void;
    cellKeyDown: (event: React_2.KeyboardEvent<HTMLElement>, column: TreeColumnBaseProps<C, H, F>) => void;
    sortIcon(sortIndex: number): (false | JSX_2.Element)[] | null;
    render(): JSX_2.Element[];
    private cells;
}

/**
 * @hidden
 */
export declare interface HeaderRowProps<C = CellProps, H = HeaderCellProps, F = FilterCellProps> extends ColumnDraggableProps {
    sortable?: SortSettings;
    sortChange?: (e: React_2.SyntheticEvent<any>, descriptors: SortDescriptor[], field?: string) => void;
    filterChange?: (e: React_2.SyntheticEvent<any>, descriptors: FilterDescriptor[], field?: string) => void;
    sort?: SortDescriptor[];
    columns: ExtendedColumnProps<C, H, F>[];
    columnsMap: number[][];
    selectionChange: (e: any) => void;
    cellRender?: (defaultRendering: React_2.ReactNode | null, props: HeaderCellProps) => React_2.ReactNode;
    columnResize?: ColumnResize<C, H, F>;
    columnMenu?: React_2.ComponentType<ColumnMenuProps>;
    columnMenuFilter?: CompositeFilterDescriptor[];
    columnMenuFilterChange?: (e: React_2.SyntheticEvent<any>, filter: CompositeFilterDescriptor[], field?: string) => void;
}

/**
 * @hidden
 */
export declare function HeaderSelectionCell(props: HeaderSelectionCellProps): JSX_2.Element;

/**
 * @hidden
 */
export declare interface HeaderSelectionCellProps extends HeaderCellProps {
    inputId: string;
}

export declare const HeaderThElement: {
    (props: HeaderThElementProps): JSX_2.Element;
    displayName: string;
};

export declare interface HeaderThElementProps extends React_2.ThHTMLAttributes<HTMLTableCellElement> {
    ariaSort?: 'none' | 'ascending' | 'descending';
    ariaLabel?: string;
    ariaColumnIndex?: number;
    ariaSelected?: boolean;
    ariaDescription?: string;
    colSpan?: number;
    rowSpan?: number;
    role?: string;
    columnId: string;
    className?: string;
    style?: any;
    children?: any;
    onKeyDown?: any;
    navigatable?: boolean;
}

/** @hidden */
export declare const isInNonSelectable: (target: HTMLElement | null) => boolean;

/**
 * @hidden
 */
export declare function isRtl(element: HTMLElement | null): boolean;

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_BODY = "data-keyboardnavbody";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_HEADER = "data-keyboardnavheader";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_ID = "data-keyboardnavid";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_LEVEL = "data-keyboardnavlevel";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_SCOPE = "data-keyboardnavscope";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_DATA_ZONE = "data-keyboardnavzone";

/**
 * @hidden
 */
export declare const KEYBOARD_NAV_FILTER_COL_SUFFIX = "_filter";

/**
 * @hidden
 */
export declare function mapColumns(columns: Array<{
    parentIndex: number;
    colSpan: number;
    rowSpan: number;
    depth: number;
    kFirst?: boolean;
    children: any[];
    width?: string | number;
    locked?: boolean;
    index: number;
    left: number;
    right: number;
    rightBorder: boolean;
    ariaColumnIndex: number;
}>, changedColumnLength?: boolean): number[][];

/**
 * Changes the `subItems` collection of each data item which matches the passed `condition`.
 *
 * @param {any[]} data - The data tree.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {(item: object) => Boolean} condition - A function that will be executed for each data item and
 * will return `true` for items that have to change the subitems collection.
 * @param {(subItems: object[]) => object[]} change - A function which
 * has as a parameter the subitems collection of the matched items and which will return the new subitems collection.
 * @returns {any[]} - The new data tree.
 */
export declare const modifySubItems: (data: any[], subItemsField: string, condition: (item: any) => boolean, change: (subItems: any[]) => any[]) => any[];

/**
 * Moves the targeted item in the tree to another position.
 *
 * @param {any[]} data - The data tree.
 * @param {number[]} target - The level of the target tree item which will be moved.
 * @param {number[] | null} destination - The level of the destination tree item where the target item will be moved in.
 * If it is null, the target item will be added at the root level.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {any[]} - The new data tree.
 */
export declare const moveTreeItem: (data: any[], target: number[], destination: number[] | null, subItemsField: string) => any[];

/**
 * @hidden
 */
export declare function nextColumn(columns: {
    depth: number;
    locked?: boolean;
}[], current: number): {
    depth: number;
    locked?: boolean | undefined;
} | null;

/**
 * @hidden
 */
export declare const normalize: (...settings: (SortSettings | ColumnSortSettings)[]) => any;

/**
 * The NumericFilter component used for editing numeric value of FilterDescriptor object.
 */
export declare class NumericFilter extends React_2.Component<NumericFilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        filter: PropTypes.Validator<object>;
        onFilterChange: PropTypes.Validator<(...args: any[]) => any>;
    };
    /**
     * @hidden
     */
    render(): JSX_2.Element;
    private onChange;
}

/**
 * @hidden
 */
export declare class NumericFilterCell extends NumericFilterCell_base {
}

declare const NumericFilterCell_base: React_2.ComponentClass<FilterComponentProps, any>;

/**
 * The props of the NumericFilter component.
 */
export declare interface NumericFilterProps extends TextFilterProps {
    /**
     * Specifies the smallest value that can be entered.
     */
    min?: number;
    /**
     * Specifies the greatest value that can be entered.
     */
    max?: number;
}

/**
 * Represents the operators for the TextFilter, NumericFilter, DateFilter and BooleanFilter components.
 *
 * The text field of each operator object will be resolved according to the
 * [localization messages]({% slug globalization_datatools %}#toc-messages).
 */
export declare class Operators {
    /**
     * An array containing the operators for the TextFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.containsOperator', operator: 'contains' }
     * - { text: 'filter.notContainsOperator', operator: 'doesnotcontain' }
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     * - { text: 'filter.startsWithOperator', operator: 'startswith' }
     * - { text: 'filter.endsWithOperator', operator: 'endswith' }
     * - { text: 'filter.isNullOperator', operator: 'isnull' }
     * - { text: 'filter.isNotNullOperator', operator: 'isnotnull' }
     * - { text: 'filter.isEmptyOperator', operator: 'isempty' }
     * - { text: 'filter.isNotEmptyOperator', operator: 'isnotempty' }
     */
    static get text(): FilterOperator[];
    /**
     * An array containing the operators for the NumericFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     * - { text: 'filter.gteOperator', operator: 'gte' }
     * - { text: 'filter.gtOperator', operator: 'gt' }
     * - { text: 'filter.lteOperator', operator: 'lte' }
     * - { text: 'filter.ltOperator', operator: 'lt' }
     * - { text: 'filter.isNullOperator', operator: 'isnull' }
     * - { text: 'filter.isNotNullOperator', operator: 'isnotnull' }
     */
    static get numeric(): FilterOperator[];
    /**
     * An array containing the operators for the DateFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     * - { text: 'filter.afterOrEqualOperator', operator: 'gte' }
     * - { text: 'filter.afterOperator', operator: 'gt' }
     * - { text: 'filter.beforeOperator', operator: 'lt' }
     * - { text: 'filter.beforeOrEqualOperator', operator: 'lte' }
     * - { text: 'filter.isNullOperator', operator: 'isnull' }
     * - { text: 'filter.isNotNullOperator', operator: 'isnotnull' }
     */
    static get date(): FilterOperator[];
    /**
     * An array containing the operators for the BooleanFilter component.
     *
     * The operators are:
     *
     * - { text: 'filter.eqOperator', operator: 'eq' }
     * - { text: 'filter.notEqOperator', operator: 'neq' }
     */
    static get boolean(): FilterOperator[];
}

/**
 * Orders the specified tree according to the provided sort descriptors.
 *
 * @param {T[]} data - The data that will be sorted.
 * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {T[]} - The sorted data.
 */
export declare function orderBy(data: any[], descriptors: SortDescriptor[], subItemsField: string): any[];

/**
 * Represents the object of the `onPageChange` event.
 */
export declare interface PageChangeEvent extends BasePageChangeEvent {
    /**
     * An event target.
     */
    target: Pager;
    /**
     * A React Synthetic Event.
     */
    syntheticEvent: React_2.SyntheticEvent<any>;
    /**
     * A native DOM event.
     */
    nativeEvent: any;
    /**
     * A target change event.
     */
    targetEvent: PagerTargetEvent;
}

export declare class Pager extends React_2.Component<PagerProps, PagerState> {
    /**
     * @hidden
     */
    static propTypes: {
        className: PropTypes.Requireable<string>;
        style: PropTypes.Requireable<object>;
        total: PropTypes.Validator<number>;
        skip: PropTypes.Validator<number>;
        take: PropTypes.Validator<number>;
        buttonCount: PropTypes.Requireable<number>;
        info: PropTypes.Requireable<boolean>;
        type: PropTypes.Requireable<string>;
        pageSizes: PropTypes.Requireable<(NonNullable<string | number | null | undefined> | null | undefined)[]>;
        previousNext: PropTypes.Requireable<boolean>;
        onPageChange: PropTypes.Requireable<(...args: any[]) => any>;
        messagesMap: PropTypes.Requireable<(...args: any[]) => any>;
        size: PropTypes.Requireable<string | null>;
        dir: PropTypes.Requireable<string>;
        disabled: PropTypes.Requireable<boolean>;
    };
    /**
     * @hidden
     */
    static defaultProps: {
        buttonCount: number;
        info: boolean;
        type: string;
        size: string;
        disabled: boolean;
    };
    private _element;
    private get isRtl();
    private get currentPage();
    /**
     * Returns the HTML element of the Pager component.
     */
    get element(): HTMLDivElement | null;
    constructor(props: PagerProps);
    /**
     * @hidden
     */
    componentDidMount(): void;
    /**
     * @hidden
     */
    componentWillUnmount(): void;
    /**
     * @hidden
     */
    render(): JSX_2.Element;
    private onPageChange;
    private renderButton;
    private get totalPages();
    private changePage;
    private onWindowResize;
    private onKeyDown;
}

export declare interface PagerProps {
    /**
     * The total number of records.
     */
    total: number;
    /**
     * The number of records that will be skipped.
     */
    skip: number;
    /**
     * The number of records that will be taken.
     */
    take: number;
    /**
     * Sets additional classes to the Pager.
     */
    className?: string;
    /**
     * The styles that are applied to the Pager.
     */
    style?: React_2.CSSProperties;
    /**
     * Sets the maximum numeric buttons count before the buttons are collapsed.
     */
    buttonCount?: number;
    /**
     * Toggles the information about the current page and the total number of records.
     */
    info?: boolean;
    /**
     * Defines the type of the pager.
     * * (Default) `numeric` â Renders buttons with numbers.
     * * `input` â Renders an input field for typing the page number.
     */
    type?: 'numeric' | 'input';
    /**
     * Displays a menu for selecting the page size.
     */
    pageSizes?: Array<number> | Array<number | string>;
    /**
     * Sets the selected value of the page size Dropdownlist.
     * It is useful when the selected value could also be a string not only a number.
     */
    pageSizeValue?: string | number;
    /**
     * Toggles the **Previous** and **Next** buttons.
     */
    previousNext?: boolean;
    /**
     * Defines if the pager will be responsive. Defaults to `true`.
     */
    responsive?: boolean;
    /**
     * Configures the `size` of the Pager.
     *
     * The available options are:
     * - small
     * - medium
     * - large
     * - null&mdash;Does not set a size `className`.
     *
     * @default `medium`
     */
    size?: null | 'small' | 'medium' | 'large';
    /**
     * Fires when the page of the Pager is changed. You have to handle the event yourself and page the data.
     */
    onPageChange?: ((event: PageChangeEvent) => void) | ((event: BasePageChangeEvent) => void);
    /**
     * Useful for modifying the Pager messages.
     */
    messagesMap?: (messageKey: string) => ({
        messageKey: string;
        defaultMessage: string;
    });
    /**
     * Sets the direction of the component.
     */
    dir?: string;
    /**
     * If set to `true`, the user can use dedicated shortcuts to interact with the Pager.
     * By default, navigation is disabled and the Pager content is accessible in the normal tab sequence.
     */
    navigatable?: boolean;
    /**
     * Controls the disabled state of the Pager. Defaults to `false`.
     */
    disabled?: boolean;
}

/**
 * @hidden
 */
declare interface PagerState {
    showPagerSizes?: boolean;
    showPagerInfo?: boolean;
    innerNavigateActive?: boolean;
}

/**
 * A Pager target event.
 */
export declare interface PagerTargetEvent {
    [key: string]: any;
    /**
     * An event target.
     */
    target?: any;
    /**
     * An event value.
     */
    value?: any;
}

/**
 * Represents the `PopulateClipboardArgs` event argument.
 */
export declare interface PopulateClipboardArgs {
    /**
     * Represents the object of the `onClipboardData` event.
     */
    event: ClipboardDataEvent;
    /**
     * Represents the current selected state of the data.
     */
    selectedState: {
        [key: string | number]: boolean | number[];
    };
    /**
     * Passes the data currently displayed.
     */
    data: any[];
    /**
     * Passes dataItemKey name of the field that could be used to make difference between dataItems.
     */
    dataItemKey?: string;
    /**
     * Passes subItemsField that will be used in grouping cases.
     */
    subItemsField?: string;
}

/**
 * A function used to populate the Clipboard data.
 */
export declare const populateClipboardData: (args: PopulateClipboardArgs) => ClipboardData;

/**
 * @hidden
 */
export declare function readColumns<C = CellProps, H = HeaderCellProps, F = FilterCellProps>(elements: TreeColumnBaseProps<C, H, F>[], idInfo: {
    prevId: number;
    idPrefix: string;
}, depth?: number): ExtendedColumnProps<C, H, F>[];

/** @hidden */
export declare const relativeContextElement: (element: any) => any;

/**
 * Removes the items from the passed `data` which match the passed `condition`.
 *
 * @param {any[]} data - The data tree.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @param {(item: object) => Boolean} condition - A function that will be executed for each data item
 * in the tree data and the items for which returns true will be removed.
 * @returns {any[]} - The new data tree.
 */
export declare const removeItems: (data: any[], subItemsField: string, condition: (item: any) => boolean) => any[];

/**
 * Apply the `expanded` prop to the group items in data based on the provided collection of group ids.
 *
 * @param {{data: any[], collapsedIds: string[]}} options - The options to be processed.
 * @returns {string[]} - Collection of all group ids from the data.
 */
export declare const setExpandedState: (options: {
    data: any;
    collapsedIds: string[];
}) => any[];

/**
 * Add unique ids to the group items inside data.
 *
 * @param {{data: any[], group: GroupDescriptor[]}} options - The options to be processed.
 */
export declare const setGroupIds: (options: {
    data: any;
    group?: Array<GroupDescriptor>;
}) => void;

/**
 * @hidden
 *
 * Apply the selected field to the data items based on the selected state.
 *
 * @param {{data: any, selectedState:  {[id: string]: boolean | number[]}, dataItemKey: string; selectedField: string; subItemsField?: string; }} options
 * @returns {any[]}
 */
export declare const setSelectedState: (options: {
    data: any;
    selectedState: {
        [id: string]: boolean | number[];
    };
    dataItemKey: string;
    selectedField: string;
    subItemsField?: string | undefined;
}) => any[];

/**
 * The settings for sorting the component data.
 */
export declare type SortSettings = boolean | ColumnSortSettings & {
    /**
     * The sort mode of the component.
     *
     * The available modes are:
     * - `single`
     * - `multiple`
     */
    mode?: 'single' | 'multiple';
};

/**
 * @hidden
 */
export declare const stringOperator: (operator: any) => boolean;

/** @hidden */
export declare const TABLE_COL_INDEX_ATTRIBUTE = "data-grid-col-index";

/** @hidden */
export declare const TABLE_PREVENT_SELECTION_ELEMENT = "data-prevent-selection";

/** @hidden */
export declare const TABLE_ROW_INDEX_ATTRIBUTE = "data-grid-row-index";

/**
 * @hidden
 */
export declare function tableColumnsVirtualization(args: {
    enabled?: boolean;
    columns: {
        width?: string | number;
        locked?: boolean;
    }[];
    tableViewPortWidth: number;
    scrollLeft: number;
}): {
    colSpans: number[];
    hiddenColumns: boolean[];
};

/** @hidden */
export declare interface TableDragSelectionReleaseEvent {
    /**
     * Selection start row index.
     */
    startRowIndex: number;
    /**
     * Selection start column index.
     */
    startColIndex: number;
    /**
     * Selection end row index.
     */
    endRowIndex: number;
    /**
     * Selection end column index.
     */
    endColIndex: number;
    /**
     * A native DOM event.
     */
    nativeEvent: any;
    /**
     * Is ctrl key modifier pressed.
     */
    ctrlKey: boolean;
    /**
     * Is alt key modifier pressed.
     */
    altKey: boolean;
    /**
     * Is meta key modifier pressed.
     */
    metaKey: boolean;
    /**
     * Is shift key modifier pressed.
     */
    shiftKey: boolean;
    /**
     * Selection mode.
     */
    mode: 'single' | 'multiple';
    /**
     * Indicates if cell selection mode is enabled.
     */
    cell: boolean;
    /**
     * Indicates if current event is created from drag.
     */
    isDrag: boolean;
}

/**
 * @hidden
 */
export declare const tableKeyboardNavigation: {
    onConstructor: (options: {
        navigatable?: boolean | undefined;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
        idPrefix?: string;
    }) => void;
    onComponentDidMount: (options: {
        scope?: HTMLElement;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
    }) => void;
    onGetSnapshotBeforeUpdate: (options: {
        document?: Document;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
    }) => void;
    onComponentDidUpdate: (options: {
        scope?: HTMLElement;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
        focusFirst?: boolean;
    }) => void;
    onFocus: (event: React_2.FocusEvent<HTMLDivElement>, options: {
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
    }) => void;
    onKeyDown: (event: React_2.KeyboardEvent<HTMLElement>, options: {
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
        onNavigationAction?: ((options: {
            event: React_2.KeyboardEvent<HTMLElement>;
            focusElement: any;
            action?: "moveToNextPage" | "moveToPrevPage" | "reorderToLeft" | "reorderToRight" | undefined;
        }) => void) | undefined;
    }) => void;
    generateMatrix: (options: {
        scope?: HTMLElement;
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
    }) => void;
    focusFirstDataElement: (options: {
        scope?: HTMLElement | undefined;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType | undefined;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType | undefined;
        };
    }, event?: any) => void;
};

/**
 * @hidden
 */
export declare const tableKeyboardNavigationBodyAttributes: {
    "data-keyboardnavbody": boolean;
};

/**
 * @hidden
 */
export declare const TableKeyboardNavigationContext: React_2.Context<TableKeyboardNavigationContextType | undefined>;

/**
 * @hidden
 */
export declare interface TableKeyboardNavigationContextType {
    activeId: string | undefined;
    level: number;
}

/**
 * @hidden
 */
export declare const tableKeyboardNavigationHeaderAttributes: {
    "data-keyboardnavheader": boolean;
};

/**
 * @hidden
 */
export declare const tableKeyboardNavigationScopeAttributes: {
    "data-keyboardnavscope": boolean;
};

/**
 * @hidden
 */
export declare interface TableKeyboardNavigationStateType {
    activeElementIsFocused: boolean;
    prevNavigationIndexes?: [number, number];
    idPrefix: string;
    navigationMatrix: string[][];
    lastHeaderIndex: number;
}

/**
 * @hidden
 */
export declare const tableKeyboardNavigationTools: {
    generateNavigatableId: (navigationId: string, idPrefix: string, type?: 'column' | 'cell' | 'group' | 'expand' | 'nodata') => string;
    getNavigatableId: (element: Element | null) => string | undefined;
    getNavigatableLevel: (element: Element | null) => number | undefined;
    getNavigatableElement: (scope: HTMLElement, options?: {
        level: number;
    }) => HTMLElement;
    getClosestNavigatableElement: (target: HTMLElement) => Element | null;
    getActiveNavDataElement: (scope: HTMLElement, activeId?: string) => HTMLElement;
    getClosestScope: (target: HTMLElement) => Element | null;
    getHeaderElement: (scope: HTMLElement) => Element | null;
    getBodyElement: (scope: HTMLElement) => Element | null;
    getFocusableElements: (scope: HTMLElement, options?: {
        focusable: boolean;
    }) => Element[];
    getNavigatableElements: (scope: HTMLElement | null, options?: {
        level: number;
    }) => any[];
    filterNavigatableElements: (options?: {
        level: number;
    }) => (element: HTMLElement) => boolean;
    focusElement: (options: {
        elementForFocus: HTMLElement;
        prevElement?: HTMLElement;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        event?: any;
    }) => void;
    getIdPrefix: (navigationStateRef: {
        current?: TableKeyboardNavigationStateType;
    }) => string;
    isNavigatable: (element: Element | null) => boolean;
    findNextIdByRowIndex: (initialRowIndex: number, cellIndex: number, elementId: string | undefined, matrix: string[][], isReverse: boolean) => [
    string,
    [
    number,
    number
    ]
    ] | [
    ];
    findNextIdByCellIndex: (rowIndex: number, initialCellIndex: number, elementId: string | undefined, matrix: string[][], isReverse: boolean) => [
    string,
    [
    number,
    number
    ]
    ] | [
    ];
    findId: (navigationMatrix: string[][], cellId?: string) => number[] | undefined;
    getNextNavigationIndex: (navigationStateRef: {
        current?: TableKeyboardNavigationStateType;
    }) => number;
    getFilterColumnId: (columnId: string) => string;
    focusFirstDataElement: (options: {
        scope?: HTMLElement;
        contextStateRef: {
            current?: TableKeyboardNavigationContextType;
        };
        navigationStateRef: {
            current?: TableKeyboardNavigationStateType;
        };
    }, event?: any) => void;
};

/** @hidden */
export declare interface TableKeyDownEvent<T> extends BaseEvent<T> {
    /**
     * The current leaf data items.
     */
    dataItems: any[];
    /**
     * Selection mode.
     */
    mode: 'single' | 'multiple';
    /**
     * Indicates if cell selection mode is enabled.
     */
    cell: boolean;
    /**
     * The `selectedField` prop of the component.
     */
    selectedField: string;
    /**
     * The component unique identifier.
     */
    componentId: string;
}

/** @hidden */
export declare type TableSelectableMode = 'single' | 'multiple';

/** @hidden */
export declare interface TableSelectableSettings {
    /**
     * Determines if selection is allowed.
     *
     * @default true
     */
    enabled?: boolean;
    /**
     * The available values are:
     * * `single`
     * * `multiple`
     *
     * @default "multiple"
     */
    mode?: TableSelectableMode;
    /**
     * Determines if cell selection is allowed.
     *
     * @default false
     */
    cell?: boolean;
    /**
     * Determines if drag selection is allowed.
     *
     * @default false
     */
    drag?: boolean;
}

/** @hidden */
export declare const TableSelection: (props: TableSelectionProps) => JSX_2.Element;

/** @hidden */
export declare interface TableSelectionChangeEvent<T> extends BaseEvent<T>, TableDragSelectionReleaseEvent {
    /**
     * The data item which was selected or deselected when the checkbox selection column is used. It will be `null` when the row or cell selection is used.
     */
    dataItem: any;
    /**
     * The `selectedField` prop of the component.
     */
    selectedField: string;
    /**
     * The component unique identifier.
     */
    componentId: string;
    /**
     * The current component leaf data items.
     */
    dataItems: any[];
}

/** @hidden */
export declare interface TableSelectionProps {
    children: any;
    selectable?: TableSelectableSettings;
    onRelease: (options: TableDragSelectionReleaseEvent) => void;
    childRef?: (childElement: HTMLElement) => void;
}

/**
 * The TextFilter component used for editing text value of FilterDescriptor object.
 */
export declare class TextFilter extends React_2.Component<TextFilterProps> {
    /**
     * @hidden
     */
    static propTypes: {
        filter: PropTypes.Validator<object>;
        onFilterChange: PropTypes.Validator<(...args: any[]) => any>;
        ariaLabel: PropTypes.Requireable<string>;
    };
    /**
     * @hidden
     */
    render(): JSX_2.Element;
    private onChange;
}

/**
 * @hidden
 */
export declare class TextFilterCell extends TextFilterCell_base {
}

declare const TextFilterCell_base: React_2.ComponentClass<FilterComponentProps, any>;

/**
 * The props of the TextFilter component.
 */
export declare interface TextFilterProps {
    /**
     * The FilterDescriptor object which will be edited.
     */
    filter: FilterDescriptor;
    /**
     * The FilterChange event, triggered while editing the FilterOperator.
     */
    onFilterChange: (event: {
        nextFilter: FilterDescriptor;
    }) => void;
    /**
     * The accessible label of the component.
     */
    ariaLabel?: string;
}

/**
 * @hidden
 */
export declare interface TreeColumnBaseProps<CellProps = CellProps, HeaderCellProps = HeaderCellProps, FilterCellProps = FilterCellProps> extends ColumnBaseProps<CellProps> {
    /**
     * A collection of child columns.
     */
    children?: TreeColumnBaseProps<CellProps, HeaderCellProps, FilterCellProps>[];
    /**
     * The column menu component. Pass the [ColumnMenuTextColumn]({% slug api_data-tools_columnmenutextcolumn %}),
     * [ColumnMenuNumericColumn]({% slug api_data-tools_columnmenunumericcolumn %}),
     * [ColumnMenuDateColumn]({% slug api_data-tools_columnmenudatecolumn %}),
     * [ColumnMenuBooleanColumn]({% slug api_data-tools_columnmenubooleancolumn %})
     * or a custom component base on the type of the column data.
     */
    columnMenu?: React.ComponentType<ColumnMenuProps>;
    /**
     * If set to `true`, the column will render the icons that are used for expanding and collapsing child rows.
     */
    expandable?: boolean;
    /**
     * Defines the component that will be rendered as an edit cell.
     */
    editCell?: ComponentType<CellProps>;
    /**
     * Defines the component that will be rendered as a header cell.
     * If not set, a `HeaderCell` will be rendered by default.
     */
    headerCell?: ComponentType<HeaderCellProps>;
    /**
     * **Deprecated**. Use `filterCell` prop instead.
     */
    filter?: ComponentType<FilterCellProps>;
    /**
     * Defines the component that will be rendered as a filter cell.
     */
    filterCell?: ComponentType<FilterCellProps>;
}

/**
 * Creates a flat data array from the passed tree dataset.
 *
 * @param {object[]} dataset - The source dataset of data items.
 * @param {string} expandField - The field which points to the expanded value of each data item.
 * @param {string} subItemsField - The field which points to the subitems collection of each data item.
 * @returns {object[]} - A collection of the generated data items that are in a flat structure.
 */
export declare const treeToFlat: (data: any[], expandField: string, subItemsField: string) => any[];

/**
 * @hidden
 */
export declare const unaryOperator: (operator: any) => boolean;

/**
 * @hidden
 */
export declare function updateLeft(columnsMap: number[][], columns: Array<{
    parentIndex: number;
    colSpan: number;
    rowSpan: number;
    depth: number;
    kFirst?: boolean;
    children: any[];
    width?: string | number;
    locked?: boolean;
    index: number;
    left: number;
    right: number;
    rightBorder: boolean;
    ariaColumnIndex: number;
}>, generateLeft?: boolean): void;

/**
 * @hidden
 */
export declare function updateRight(columnsMap: number[][], columns: Array<{
    parentIndex: number;
    colSpan: number;
    rowSpan: number;
    depth: number;
    kFirst?: boolean;
    children: any[];
    width?: string | number;
    locked?: boolean;
    index: number;
    left: number;
    right: number;
    rightBorder: boolean;
    ariaColumnIndex: number;
}>, generateRight?: boolean): void;

/**
 * @hidden
 */
export declare const useTableKeyboardNavigation: (elementId: string, navigatable?: boolean) => {
    tabIndex?: undefined;
    "data-keyboardnavlevel"?: undefined;
    "data-keyboardnavid"?: undefined;
} | {
    tabIndex: number;
    "data-keyboardnavlevel": number;
    "data-keyboardnavid": string;
};

export { }
