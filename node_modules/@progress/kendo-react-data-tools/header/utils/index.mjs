/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { generateNavigatableId as o } from "../../navigation/utils.mjs";
import { ColumnDefaultProps as g } from "../ColumnProps.mjs";
function c(t, d) {
  const n = t[d].depth;
  let i = null;
  for (let h = d + 1; h < t.length; h++)
    if (t[h].depth === n) {
      i = t[h];
      break;
    }
  return i;
}
const p = (t) => {
  let d = t.width ? parseFloat(t.width.toString()) : 0;
  return !d && t.children && t.children.length && (d = t.children.reduce((n, i) => p(i) + n, 0)), d;
};
function I(t, d) {
  const n = [[]];
  let i = 0;
  for (let e = t.length - 1; e >= 0; e--)
    i = Math.max(i, t[e].depth), t[e].colSpan = t[e].colSpan || 1, t[e].children.length > 0 && (t[e].colSpan = t[e].children.reduce((l, a) => a.hidden ? l : l + a.colSpan, 0));
  const h = [];
  let r = 1;
  return t.forEach((e, l) => {
    n[e.depth] = n[e.depth] || [];
    let a = !1;
    n[e.depth].length === 0 && (r <= 1 ? r = 1 + (e.children.length > 0 ? 0 : i - e.depth) : (r--, a = !0)), e.rowSpan = 1 + (e.children.length > 0 ? 0 : i - e.depth), e.kFirst = a, e.index = n[e.depth].length, n[e.depth].push(l), e.ariaColumnIndex = h[e.depth] ? h[e.depth] + 1 : 1;
    for (let f = e.depth; f < e.depth + e.rowSpan; f++)
      h[f] = (h[f] || 0) + e.colSpan;
  }), x(n, t, d), s(n, t, d), n;
}
function x(t, d, n) {
  let i = new Array(t.length).fill(0), h = 0;
  d.forEach((r) => {
    if (r.locked && (!r.left || n))
      if (r.left = i[r.depth], h = p(r), r.children.length === 0)
        for (let e = r.depth; e < i.length; e++)
          i[e] += h;
      else
        i[r.depth] += h;
  });
}
function s(t, d, n) {
  let i = 0, h = new Array(t.length).fill(0);
  for (let r = d.length - 1; r >= 0; r--) {
    const e = d[r];
    if (e.locked && (!e.right || n)) {
      if (e.right = h[e.depth], i = p(e), e.children.length === 0)
        for (let a = e.depth; a < h.length; a++)
          h[a] += i;
      else
        h[e.depth] += i;
      const l = c(d, r);
      e.rightBorder = !(l && l.locked);
    }
  }
}
function w(t, d, n = 0) {
  let i = [];
  if (!t || !t.length)
    return [];
  t.forEach((r) => {
    const e = w(r.children || [], d, n + 1);
    i.push(
      Object.assign(
        {},
        { depth: n },
        g,
        r,
        {
          id: r.id ? r.id : o(`${d.prevId++}`, d.idPrefix, "column"),
          declarationIndex: i.length,
          children: e,
          rowSpan: 0,
          colSpan: 0,
          isAccessible: !0
        }
      )
    );
  });
  const h = (r, e) => r.orderIndex === e.orderIndex ? r.declarationIndex - e.declarationIndex : (r.orderIndex || 0) - (e.orderIndex || 0);
  if (i.sort(h), n === 0) {
    let r = [];
    const e = (l, a) => l.forEach((f) => {
      f.parentIndex = a, e(f.children, r.push(f) - 1);
    });
    return e(i, -1), r;
  }
  return i;
}
function E(t) {
  return !!(t && getComputedStyle(t).direction === "rtl");
}
function k(t, d) {
  if (!d || !t || !t.originalEvent)
    return -1;
  const n = { x: t.clientX, y: t.originalEvent.clientY };
  let i = d.ownerDocument ? d.ownerDocument.elementFromPoint(n.x, n.y) : null;
  for (; i && i.parentElement !== d; )
    i = i.parentElement;
  if (!i && d.matches("tr")) {
    const r = (e) => {
      const l = e.getBoundingClientRect();
      return n.x > l.left && n.x < l.left + l.width && n.y > l.top && n.y < l.top + l.height;
    };
    i = Array.from(d.children).find(r) || null;
  }
  const h = d.children;
  for (let r = 0; r < h.length; r++)
    if (h[r] === i)
      return r;
  return -1;
}
export {
  k as getIndex,
  E as isRtl,
  I as mapColumns,
  c as nextColumn,
  w as readColumns,
  x as updateLeft,
  s as updateRight
};
