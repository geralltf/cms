/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { getter as _, mapTree as k, extendDataItem as B, Keys as i, hasRelativeStackingContext as O } from "@progress/kendo-react-common";
import { TABLE_PREVENT_SELECTION_ELEMENT as M, TABLE_ROW_INDEX_ATTRIBUTE as F, TABLE_COL_INDEX_ATTRIBUTE as G } from "./constants.mjs";
const U = "items", x = {}, X = (e, t) => !e || Array.isArray(e) && e.length === 0 ? [t] : e.findIndex((d) => d === t) > -1 ? e.filter((d) => d !== t) : [...e, t], J = (e) => {
  let t = e;
  for (; t; ) {
    if (t.hasAttribute(M))
      return !0;
    t = t.parentElement;
  }
  return !1;
}, A = (e, t) => {
  let o = e;
  for (; o; ) {
    if (o.tagName === t)
      return o;
    if (o.tagName === "TABLE")
      return null;
    o = o.parentElement;
  }
  return null;
}, b = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(F);
  return t ? parseInt(t, 10) : void 0;
}, V = (e) => {
  if (!e)
    return;
  const t = e.getAttribute(G);
  return t ? parseInt(t, 10) : void 0;
}, Q = (e) => {
  const t = e.subItemsField || U, o = _(e.dataItemKey);
  return k(
    e.data,
    t,
    (d) => B(d, t, {
      [e.selectedField]: e.selectedState[o(d)]
    })
  );
}, Y = (e) => {
  const { event: t, dataItemKey: o, selectedState: d } = e, { syntheticEvent: a, nativeEvent: n, dataItems: E, componentId: c, mode: T, cell: g, selectedField: p } = t, { target: C, ctrlKey: w, metaKey: S, altKey: I, shiftKey: h } = n;
  if (a.isDefaultPrevented() && !h || n.keyCode !== i.space && n.keyCode !== i.enter && n.keyCode !== i.right && n.keyCode !== i.left && n.keyCode !== i.up && n.keyCode !== i.down)
    return d;
  a.preventDefault();
  const D = A(C, "TD"), m = A(C, "TR");
  let r = V(D), u = b(m), s = {};
  return D && m && u !== void 0 && r !== void 0 && (n.keyCode === i.right && r++, n.keyCode === i.left && r--, n.keyCode === i.down && u++, n.keyCode === i.up && u--, s = H({
    selectedState: d,
    dataItemKey: o,
    event: {
      ctrlKey: w,
      metaKey: S,
      altKey: I,
      shiftKey: h,
      dataItems: E,
      cell: g,
      mode: T,
      selectedField: p,
      componentId: c,
      startColIndex: r,
      endColIndex: r,
      startRowIndex: u,
      endRowIndex: u,
      isDrag: !1,
      syntheticEvent: a,
      nativeEvent: n,
      target: t.target,
      dataItem: null
    }
  })), s;
}, H = (e) => {
  const { event: t, dataItemKey: o, selectedState: d } = e, {
    dataItems: a,
    startRowIndex: n,
    endRowIndex: E,
    startColIndex: c,
    endColIndex: T,
    cell: g,
    isDrag: p,
    ctrlKey: C,
    shiftKey: w,
    metaKey: S,
    componentId: I,
    mode: h,
    dataItem: D
  } = t, m = _(o);
  let r = {};
  const u = D !== null;
  if (h === "single") {
    const s = a.slice(n, n + 1)[0], f = m(s);
    x[I] = {
      rowIndex: n,
      colIndex: c
    }, r[f] = g ? [c] : !0;
  } else if (p || !w && !C && !S && !u) {
    p || (x[I] = {
      rowIndex: n,
      colIndex: c
    });
    const s = [];
    for (let l = c; l <= T; l++)
      s.push(l);
    a.slice(n, E + 1).forEach((l) => {
      const R = m(l);
      r[R] = g ? [...s] : !0;
    });
  } else if (C || S || u) {
    x[I] = {
      rowIndex: n,
      colIndex: c
    };
    const f = a.slice(n, E + 1)[0], l = m(f);
    r = { ...d }, r[l] = g && !u ? X(r[l], c) : !r[l];
  } else if (w) {
    const s = x[I] && x[I].rowIndex || 0, f = x[I] && x[I].colIndex || 0, l = Math.min(s, n, E), R = Math.max(s, n, E), K = Math.min(f, c, T), L = Math.max(f, c, T), v = [];
    for (let y = K; y <= L; y++)
      v.push(y);
    a.slice(l, R + 1).forEach((y) => {
      const N = m(y);
      r[N] = g ? [...v] : !0;
    });
  }
  return r;
}, W = O(), Z = (e) => {
  if (!e || !W)
    return null;
  let t = e.parentElement;
  for (; t; ) {
    if (window.getComputedStyle(t).transform !== "none")
      return t;
    t = t.parentElement;
  }
}, $ = (e) => {
  if (e && e.ownerDocument && e !== e.ownerDocument.body) {
    const t = e.getBoundingClientRect();
    return {
      left: t.left - e.scrollLeft,
      top: t.top - e.scrollTop
    };
  }
  return { left: 0, top: 0 };
}, P = (e) => {
  const t = e ? typeof e.enabled == "boolean" ? e.enabled : !0 : !1, o = e ? !!e.drag : !1, d = e && e.mode ? e.mode : "multiple", a = !!(e && e.cell);
  return { enabled: t, drag: o, mode: d, cell: a };
};
export {
  A as closestTagName,
  V as getColumnIndex,
  $ as getOffset,
  b as getRowIndex,
  H as getSelectedState,
  Y as getSelectedStateFromKeyDown,
  P as getSelectionOptions,
  J as isInNonSelectable,
  Z as relativeContextElement,
  Q as setSelectedState
};
