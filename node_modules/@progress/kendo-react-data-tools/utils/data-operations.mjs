/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { orderBy as v, filterBy as D } from "@progress/kendo-data-query";
import { extendDataItem as y, mapTree as C, getItemPath as P, getNestedValue as g } from "@progress/kendo-react-common";
function i(e, t, n) {
  return n ? { ...e, [t]: n.length ? [...n] : void 0 } : e && e[t] ? [...e[t]] : [];
}
function s(e, t, n) {
  if (e[n]) {
    let r = i(e, n, v(i(e, n), t)), o = i(r, n).map((c) => s(c, t, n));
    return { ...r, [n]: o };
  }
  return e;
}
function $(e, t, n) {
  let r = v(e, t);
  return r = r.map((o) => s(o, t, n)), r;
}
function B(e, t, n) {
  let r = i(e, n);
  if (r && r.length) {
    r = r.map((l) => B(l, t, n));
    const a = D(r, {
      filters: [
        { filters: t, logic: "and" },
        { operator: (l) => !!(l[n] || []).length }
      ],
      logic: "or"
    });
    return i(e, n, a);
  }
  return e;
}
function k(e, t, n) {
  let r = { [n]: [...e] };
  return r = B(r, t, n), r[n] || [];
}
function N(e, t, n) {
  let r = [];
  const o = [];
  for (let c = e.length - 1; c >= 0; c--) {
    const a = e[c];
    r.push({
      root: a,
      data: t(a),
      level: [c],
      levelCount: e.length
    });
  }
  for (; r.length > 0; ) {
    let c = r.pop();
    if (o.push({
      dataItem: c.root,
      level: [...c.level],
      ...n(c.root),
      levelCount: c.levelCount
    }), c.data.length)
      for (let a = c.data.length - 1; a >= 0; a--) {
        const l = c.data[a];
        r.push({
          root: l,
          data: t(l),
          level: [...c.level, a],
          levelCount: c.data.length
        });
      }
  }
  return o;
}
const S = (e, t, n) => {
  const r = (h) => !!g(t, h), o = (h) => !!g(n, h), c = (h) => {
    const f = [];
    return r(h) && o(h) && f.push(...g(n, h)), f;
  }, a = (h, f, p) => {
    f.push({ ...h, level: p }), c(h).forEach((x) => a(x, f, p + 1));
  }, l = [];
  return e.forEach((h) => a(h, l, 0)), l;
}, V = (e, t, n, r) => {
  let o = {}, c = [], a;
  return e.forEach((l) => o[t(l)] = { ...l }), e.forEach((l) => {
    a = o[n(l)], a ? (a[r] = a[r] || [], a[r].push(o[t(l)])) : c.push(o[t(l)]);
  }), c;
}, j = (e, t, n) => y(e, t, n), q = (e, t, n) => [...C(
  [{ [t]: [...e] }],
  t,
  (o) => T(o, n, t)
)[0][t]], T = (e, t, n) => {
  const r = e[n] || [], o = r.findIndex(t);
  if (o !== -1) {
    const c = [...r];
    return c.splice(o, 1), {
      ...e,
      [n]: c
    };
  }
  return e;
}, z = (e, t, n, r) => C(
  e,
  t,
  (o) => n(o) ? { ...o, [t]: r(o[t] || []) } : o
), u = (e, t, n) => P(e, t, n), A = (e, t, n, r) => {
  const o = [...e], c = u(o, t, r), a = c.pop(), l = c.pop(), h = t[t.length - 1];
  if (n) {
    const p = u(o, n, r).pop();
    (l ? l[r] : o).splice(h, 1), p[r] = p[r] || [], p[r].push(a);
  } else
    (l ? l[r] : o).splice(h, 1), o.push(a);
  return o;
};
export {
  V as createDataTree,
  j as extendDataItem,
  k as filterBy,
  N as flatData,
  u as getItemPath,
  z as modifySubItems,
  A as moveTreeItem,
  $ as orderBy,
  q as removeItems,
  S as treeToFlat
};
