/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as e from "react";
import a from "prop-types";
import { createPropsContext as ge, validatePackage as ye, usePropsContext as xe, useId as Ve, dispatchEvent as E, Keys as U, useDir as Ee, classNames as P, kendoThemeMaps as $, getTabIndex as Pe } from "@progress/kendo-react-common";
import { packageMetadata as Be } from "../package-metadata.mjs";
import { useLocalization as Ie } from "@progress/kendo-react-intl";
import { messages as Me, checkboxValidation as Ne, checkboxOptionalText as ze } from "../messages/index.mjs";
const Se = ge(), W = e.forwardRef((j, G) => {
  ye(Be);
  const B = xe(Se, j), {
    ariaDescribedBy: J,
    ariaLabelledBy: Q,
    checked: I,
    className: X,
    labelClassName: Y,
    children: Z,
    defaultChecked: _,
    disabled: l,
    defaultValue: ee,
    id: M,
    size: m = A.size,
    rounded: b = A.rounded,
    label: N,
    labelPlacement: z,
    name: ae,
    labelOptional: te,
    onChange: p,
    onFocus: k,
    onBlur: f,
    tabIndex: le,
    value: s,
    required: h,
    valid: S,
    validationMessage: D,
    validityStyles: F,
    // Removed to support direct use in Form Field component
    visited: De,
    touched: Fe,
    modified: Ke,
    ...ne
  } = B, n = e.useRef(null), K = e.useCallback(
    () => {
      n.current && n.current.focus();
    },
    []
  ), c = e.useCallback(
    () => ({
      element: n.current,
      focus: K,
      get name() {
        return n.current && n.current.name;
      }
    }),
    [K]
  );
  e.useImperativeHandle(G, c);
  const [oe, se] = e.useState(_), [ce, re] = e.useState(ee), T = typeof s == "boolean" || s === null, v = I !== void 0, r = T, C = r ? s : ce, i = v ? I : r ? void 0 : oe, w = i === void 0 && C, g = w ? C : i, d = w || r ? s === null ? s : void 0 : s || C, L = g === null || d === null, O = Ve(), ie = Ie(), R = (t) => ie.toLanguageString(t, Me[t]), q = R(Ne), de = R(ze), y = S !== void 0 ? S : h ? !!i : !0;
  e.useEffect(
    () => {
      n.current && n.current.setCustomValidity && n.current.setCustomValidity(
        y ? "" : D || q
      );
    },
    [y, D, q]
  );
  const u = e.useCallback(
    (t, o) => {
      !r && !l && (re(o), !v && !l && se(o)), p && !l && E(
        p,
        t,
        {
          ...c(),
          value: o
        },
        { value: o }
      );
    },
    [v, l, p, r, c]
  ), ue = e.useCallback(
    (t) => {
      const o = t.target.checked;
      u(t, o);
    },
    [u, s]
  ), me = e.useCallback(
    (t) => {
      if (l)
        return;
      const { keyCode: o } = t, Ce = t.currentTarget.checked;
      o === U.space && (t.preventDefault(), t.stopPropagation(), u(t, !Ce));
    },
    [l, u]
  ), be = e.useCallback(
    (t) => {
      if (l)
        return;
      const { keyCode: o } = t;
      o === U.space && t.preventDefault();
    },
    [l]
  ), pe = e.useCallback(
    (t) => {
      k && !l && E(
        k,
        t,
        c(),
        void 0
      );
    },
    [k, l, c]
  ), ke = e.useCallback(
    (t) => {
      f && !l && E(
        f,
        t,
        c(),
        void 0
      );
    },
    [f, l, c]
  ), fe = Ee(n, B.dir), he = P(
    "k-checkbox-wrap",
    X
  ), H = {
    type: "checkbox",
    className: P(
      "k-checkbox",
      {
        [`k-checkbox-${$.sizeMap[m] || m}`]: m,
        [`k-rounded-${$.roundedMap[b] || b}`]: b,
        "k-indeterminate": L,
        "k-disabled": l,
        "k-invalid k-invalid": !(y || F !== void 0 || F === !0)
      }
    ),
    ref: n,
    name: ae,
    id: M || O,
    "aria-labelledby": Q,
    "aria-describedby": J,
    checked: !!g,
    disabled: l,
    tabIndex: Pe(le, l),
    role: "checkbox",
    required: h !== void 0 ? h : !1,
    "aria-checked": i || g ? !0 : L ? "mixed" : !1,
    "aria-disabled": l || void 0,
    ...ne,
    onChange: ue,
    onKeyDown: me,
    onKeyUp: be,
    onFocus: pe,
    onBlur: ke
  }, ve = (
    // removing value prop is required due to bug in react where
    // value set to undefined override default submit value
    d === void 0 ? /* @__PURE__ */ e.createElement("input", { ...H }) : /* @__PURE__ */ e.createElement("input", { ...H, value: T ? void 0 : d === null ? "" : d })
  ), x = N !== void 0 ? /* @__PURE__ */ e.createElement(
    "label",
    {
      className: P("k-checkbox-label", Y),
      htmlFor: M || O,
      style: { userSelect: "none" }
    },
    /* @__PURE__ */ e.createElement(e.Fragment, null, N),
    te && /* @__PURE__ */ e.createElement("span", { className: "k-label-optional" }, de)
  ) : null, V = /* @__PURE__ */ e.createElement("span", { className: he }, ve, Z);
  return /* @__PURE__ */ e.createElement(e.Fragment, null, z === "before" ? /* @__PURE__ */ e.createElement("div", { dir: "rtl" }, V, x) : z === "after" ? /* @__PURE__ */ e.createElement("div", { dir: "ltr" }, V, x) : /* @__PURE__ */ e.createElement("div", { dir: fe }, V, x));
});
W.propTypes = {
  checked: a.bool,
  className: a.string,
  defaultChecked: a.bool,
  defaultValue: a.any,
  dir: a.string,
  disabled: a.bool,
  id: a.string,
  size: a.oneOf([null, "small", "medium", "large"]),
  rounded: a.oneOf([null, "small", "medium", "large"]),
  ariaLabelledBy: a.string,
  ariaDescribedBy: a.string,
  label: a.any,
  labelPlacement: a.string,
  labelOptional: a.bool,
  name: a.string,
  tabIndex: a.number,
  value: a.any,
  validationMessage: a.string,
  required: a.bool,
  validate: a.bool,
  valid: a.bool,
  onChange: a.func,
  onFocus: a.func,
  onBlur: a.func
};
const A = {
  size: "medium",
  rounded: "medium"
};
W.displayName = "KendoCheckbox";
export {
  W as Checkbox,
  Se as CheckboxPropsContext
};
