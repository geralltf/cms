/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { SignaturePad as Oe } from "@progress/kendo-inputs-common";
import { Button as D } from "@progress/kendo-react-buttons";
import { createPropsContext as xe, validatePackage as Me, usePropsContext as we, useIsomorphicLayoutEffect as Le, dispatchEvent as h, classNames as T, kendoThemeMaps as ee, getTabIndex as Ie, noop as p, Keys as Pe } from "@progress/kendo-react-common";
import { Dialog as De } from "@progress/kendo-react-dialogs";
import { useLocalization as Te } from "@progress/kendo-react-intl";
import a from "prop-types";
import * as o from "react";
import { signatureMaximize as te, messages as B, signatureMinimize as oe, signatureClear as ne } from "../messages/index.mjs";
import { packageMetadata as Be } from "../package-metadata.mjs";
import { hasParent as Re } from "./utils/index.mjs";
import { hyperlinkOpenIcon as ae, xIcon as Fe } from "@progress/kendo-svg-icons";
const _e = 250, Ne = 84, ie = 3, se = 2, qe = "#000000", Ge = "#ffffff", re = (u) => u !== void 0, We = xe(), R = o.forwardRef((u, le) => {
  Me(Be);
  const F = we(We, u), e = o.useMemo(() => ({
    strokeWidth: i.strokeWidth,
    smooth: i.smooth,
    popupScale: i.popupScale,
    exportScale: i.exportScale,
    maximizable: i.maximizable,
    disabled: i.disabled,
    required: i.required,
    validityStyles: i.validityStyles,
    onChange: i.onChange,
    onFocus: i.onFocus,
    onBlur: i.onBlur,
    onOpen: i.onOpen,
    onClose: i.onClose,
    size: i.size,
    rounded: i.rounded,
    fillMode: i.fillMode,
    ...F
  }), [F]), z = Te(), l = o.useRef(null), g = o.useRef(null), _ = o.useRef(null), N = o.useRef(null), q = o.useRef(null), [r, ce] = o.useState(), [b, G] = o.useState(!1), [S, W] = o.useState(!1), [k, A] = o.useState(), [ue, de] = o.useState(), V = re(e.value) ? e.value : k, [me, fe] = o.useState(!1), f = re(e.open), m = f ? e.open : me, pe = e.maximized || S || !e.maximizable || e.disabled, ge = !(e.maximized && !S), be = !(!(e.value || k) || S || e.readOnly || e.disabled), j = z.toLanguageString(te, B[te]), U = z.toLanguageString(oe, B[oe]), H = z.toLanguageString(ne, B[ne]), E = e.popupScale || ie, O = e.exportScale || se, x = (t) => {
    A(t), e.onChange && e.onChange({ value: t });
  }, ke = (t) => {
    r == null || r.loadImage(t.value), x(t.value);
  };
  o.useEffect(() => {
    e.value !== k && (A(e.value), r == null || r.loadImage(e.value));
  }, [e.value]);
  const ye = () => {
    r == null || r.clear(), x();
  }, y = o.useCallback(
    (t) => {
      f || fe(t);
    },
    [f]
  ), Ce = (t) => {
    var n, s;
    Q(t), (s = ((n = q.current) == null ? void 0 : n.element) || g.current) == null || s.focus();
  }, M = o.useCallback(() => {
    let t = qe;
    return !e.color && typeof document != "undefined" && l.current && (t = getComputedStyle(l.current).color), e.color || t;
  }, [e.color]), w = o.useCallback(() => {
    let t = Ge;
    return !e.backgroundColor && typeof document != "undefined" && l.current && (t = getComputedStyle(l.current).backgroundColor), e.backgroundColor || t;
  }, [e.backgroundColor]), K = () => ({
    scale: e.maximized ? e.popupScale : 1,
    color: M(),
    backgroundColor: w(),
    strokeWidth: e.strokeWidth,
    smooth: e.smooth,
    readonly: e.readOnly
  }), $ = async (t) => {
    const { width: n, height: s } = t;
    return await (r == null ? void 0 : r.exportImage({
      width: n * O,
      height: s * O
    }));
  };
  o.useEffect(() => {
    const t = g.current, n = new Oe(t, K());
    return V && n.loadImage(V), ce(n), () => n.destroy();
  }, []), o.useEffect(() => {
    r == null || r.setOptions({
      onChange: async () => x(await $(Y())),
      onDraw: () => W(!0),
      onDrawEnd: () => W(!1)
    });
  }, [r]), Le(
    () => r == null ? void 0 : r.setOptions(K()),
    [e.readOnly, e.color, e.backgroundColor, e.strokeWidth, e.smooth]
  ), o.useEffect(() => {
    var s, d;
    const t = (d = (s = _.current) == null ? void 0 : s.element) == null ? void 0 : d.querySelector(".k-overlay");
    if (!t)
      return;
    const n = () => y(!1);
    return t.addEventListener("click", n), () => t.removeEventListener("click", n);
  }, [m]), o.useEffect(() => {
    if (!m || typeof document == "undefined")
      return;
    const t = (n) => {
      n.keyCode === Pe.esc && y(!1);
    };
    return document.addEventListener("keydown", t), () => document.removeEventListener("keydown", t);
  }, [m]), o.useEffect(() => {
    var t, n;
    e.maximized && ((n = (t = N.current) == null ? void 0 : t.element) == null || n.focus());
  }, []);
  const L = o.useCallback(
    () => {
      var t;
      return (t = g.current) == null ? void 0 : t.focus();
    },
    []
  ), C = o.useCallback(
    () => e.value,
    [e.value]
  ), X = o.useCallback(
    () => e.name,
    [e.name]
  ), v = o.useCallback(
    () => e.required,
    [e.required]
  ), I = o.useCallback(
    () => {
      const t = e.validationMessage !== void 0, s = !C(), d = e.valid !== void 0 ? e.valid : !v() || !s;
      return {
        customError: t,
        valid: d,
        valueMissing: s
      };
    },
    [e.validationMessage, e.valid, C, v]
  ), P = o.useCallback(
    () => e.validityStyles,
    [e.validityStyles]
  ), J = o.useCallback(
    () => e,
    [e]
  ), c = o.useCallback(
    () => {
      const t = {
        element: l.current,
        focus: L
      };
      return Object.defineProperty(t, "name", { get: X }), Object.defineProperty(t, "value", { get: C }), Object.defineProperty(t, "validity", { get: I }), Object.defineProperty(t, "validityStyles", { get: P }), Object.defineProperty(t, "required", { get: v }), Object.defineProperty(t, "props", { get: J }), Object.defineProperty(t, "color", { get: M }), Object.defineProperty(t, "backgroundColor", { get: w }), t;
    },
    [X, C, I, P, v, L, J, M, w]
  );
  o.useImperativeHandle(le, c);
  const ve = o.useCallback(
    (t) => {
      b || e.maximized || (G(!0), h(
        e.onFocus,
        t,
        c(),
        {}
      ));
    },
    [b, e.onFocus, c]
  ), he = o.useCallback(
    (t) => {
      Re(t.relatedTarget, l.current) || (G(!1), h(
        e.onBlur,
        t,
        c(),
        {}
      ));
    },
    [b, e.onBlur, c]
  ), ze = o.useCallback(
    async (t) => {
      de(await $(Z())), y(!0), h(
        e.onOpen,
        t,
        c(),
        {}
      );
    },
    [m, f, e.onOpen, e.value, k, c]
  ), Q = o.useCallback(
    (t) => {
      y(!1), h(
        e.onClose,
        t,
        c(),
        {}
      );
    },
    [m, f, e.onClose, c]
  ), Se = () => {
    ye(), L();
  }, Y = () => {
    var s, d;
    const t = e.width || ((s = l.current) == null ? void 0 : s.offsetWidth) || _e, n = e.height || ((d = l.current) == null ? void 0 : d.offsetHeight) || Ne;
    return {
      width: t,
      height: n
    };
  }, Z = () => {
    const { width: t, height: n } = Y();
    return {
      width: t * E,
      height: n * E
    };
  }, Ee = !P() || I().valid;
  return /* @__PURE__ */ o.createElement(
    "div",
    {
      ref: l,
      dir: e.dir,
      style: { width: e.width, height: e.height, ...e.style },
      className: T(
        "k-input",
        "k-signature",
        {
          "k-signature-maximized": e.maximized,
          [`k-signature-${ee.sizeMap[e.size] || e.size}`]: e.size,
          [`k-signature-${e.fillMode}`]: e.fillMode,
          [`k-input-${e.fillMode}`]: e.fillMode,
          [`k-rounded-${ee.roundedMap[e.rounded] || e.rounded}`]: e.rounded,
          "k-invalid": !Ee,
          "k-required": e.required,
          "k-disabled": e.disabled,
          "k-focus": b
        },
        e.className
      ),
      onFocus: ve,
      onBlur: he
    },
    /* @__PURE__ */ o.createElement(
      "div",
      {
        className: "k-signature-canvas",
        ref: g,
        tabIndex: Ie(e.tabIndex, e.disabled),
        role: "img",
        id: e.id,
        "aria-label": e.ariaLabel,
        "aria-labelledby": e.ariaLabelledBy,
        "aria-describedby": e.ariaDescribedBy,
        "aria-disabled": e.disabled ? "true" : void 0
      }
    ),
    /* @__PURE__ */ o.createElement("div", { className: "k-signature-actions k-signature-actions-top" }, /* @__PURE__ */ o.createElement(
      D,
      {
        type: "button",
        className: T("k-signature-action", "k-signature-maximize", { "k-hidden": e.disabled || pe }),
        ref: q,
        icon: "hyperlink-open",
        svgIcon: ae,
        fillMode: "flat",
        size: e.size,
        onClick: ze,
        "aria-label": j,
        title: j
      }
    ), /* @__PURE__ */ o.createElement(
      D,
      {
        type: "button",
        className: T("k-signature-action", "k-signature-minimize", "k-rotate-180", { "k-hidden": e.disabled || ge }),
        ref: N,
        icon: "hyperlink-open",
        svgIcon: ae,
        fillMode: "flat",
        size: e.size,
        onClick: Q,
        "aria-label": U,
        title: U
      }
    )),
    !e.hideLine && /* @__PURE__ */ o.createElement(
      "div",
      {
        className: "k-signature-line",
        style: { zIndex: 2, pointerEvents: "none" }
      }
    ),
    /* @__PURE__ */ o.createElement("div", { className: "k-signature-actions k-signature-actions-bottom" }, be && /* @__PURE__ */ o.createElement(
      D,
      {
        type: "button",
        className: "k-signature-action k-signature-clear",
        icon: "x",
        svgIcon: Fe,
        fillMode: "flat",
        size: e.size,
        onClick: Se,
        "aria-label": H,
        title: H
      }
    )),
    m && /* @__PURE__ */ o.createElement(De, { ref: _ }, /* @__PURE__ */ o.createElement(
      R,
      {
        ...e,
        ...Z(),
        value: ue,
        maximized: !0,
        exportScale: 1 / E * O,
        open: !1,
        onChange: ke,
        onClose: Ce
      }
    ))
  );
});
R.propTypes = {
  value: a.string,
  width: a.number,
  height: a.number,
  tabIndex: a.number,
  dir: a.string,
  ariaDescribedBy: a.string,
  ariaLabelledBy: a.string,
  ariaLabel: a.string,
  readOnly: a.bool,
  disabled: a.bool,
  validationMessage: a.string,
  required: a.bool,
  onChange: a.func,
  onFocus: a.func,
  onBlur: a.func,
  onOpen: a.func,
  onClose: a.func,
  size: a.oneOf([null, "small", "medium", "large"]),
  rounded: a.oneOf([null, "small", "medium", "large"]),
  fillMode: a.oneOf([null, "solid", "flat", "outline"])
};
const i = {
  strokeWidth: 1,
  smooth: !1,
  popupScale: ie,
  exportScale: se,
  maximizable: !0,
  disabled: !1,
  required: !1,
  validityStyles: !0,
  onChange: (u) => p,
  onFocus: (u) => p,
  onBlur: (u) => p,
  onOpen: (u) => p,
  onClose: (u) => p,
  size: "medium",
  rounded: "medium",
  fillMode: "solid"
};
R.displayName = "KendoSignature";
export {
  R as Signature,
  We as SignaturePropsContext
};
