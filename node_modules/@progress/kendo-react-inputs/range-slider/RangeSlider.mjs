/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as a from "react";
import R from "prop-types";
import { createPropsContext as Y, validatePackage as _, usePropsContext as j, useDir as F, Keys as p, useDraggable as J, classNames as Q, getTabIndex as V } from "@progress/kendo-react-common";
import { sliderDragTitle as $, messages as z } from "../messages/index.mjs";
import { useLocalization as U } from "@progress/kendo-react-intl";
import { RANGE_ACTION as n, rangeReducer as Z } from "./range-raducer.mjs";
import { packageMetadata as ee } from "../package-metadata.mjs";
const te = (r, l, u) => {
  const [e, s] = a.useState(r), o = a.useCallback(
    (v) => {
      const b = Z(l.state || e, { ...v, ...l });
      u && u(b, v.event), s(b);
    },
    [l, u]
  );
  return [e, o];
}, ae = Y(), P = a.forwardRef((r, l) => {
  _(ee);
  const u = j(ae, r), e = {
    step: g.step,
    defaultValue: g.defaultValue,
    vertical: g.vertical,
    disabled: g.disabled,
    ...u
  }, s = a.useRef(null), o = a.useRef(null), v = a.useRef(null), b = a.useRef(null), T = a.useRef(null), K = a.useCallback(
    () => {
      b.current && b.current.focus();
    },
    [b]
  );
  a.useImperativeHandle(s, () => ({
    element: o.current,
    focus: K,
    props: e
  })), a.useImperativeHandle(l, () => s.current);
  const m = a.useMemo(
    () => e.min,
    [e.min]
  ), k = a.useMemo(
    () => e.max,
    [e.max]
  ), A = a.useMemo(
    () => e.step !== void 0 ? e.step : g.step,
    [e.step, g.step]
  ), f = F(o, e.dir), H = (t, d) => {
    e.onChange && s.current && e.onChange.call(void 0, {
      value: t,
      target: s.current,
      syntheticEvent: d
    });
  }, [E, S] = a.useState(""), [x, i] = te(
    e.defaultValue || g.defaultValue,
    {
      min: m,
      max: k,
      step: A,
      state: e.value
    },
    H
  ), c = a.useMemo(
    () => e.value || x,
    [e.value, x]
  ), L = a.useRef(null), w = a.useRef(null), y = a.useMemo(
    () => (c.start - m) / (k - m) * 100,
    [c.start, m, k]
  ), D = a.useMemo(
    () => (c.end - m) / (k - m) * 100,
    [c.end, m, k]
  ), N = a.useMemo(
    () => e.vertical ? { paddingTop: 0, height: "100%" } : {},
    [e.vertical]
  ), q = a.useMemo(
    () => e.vertical ? { marginTop: "0.5rem", marginBottom: "0.5rem" } : { marginLeft: "0.5rem", marginRight: "0.5rem" },
    [e.vertical]
  ), M = U(), C = a.useCallback(
    (t) => {
      if (!w.current)
        return;
      const d = w.current.getBoundingClientRect(), h = e.vertical ? d.bottom - t.clientY : f === "rtl" ? d.right - t.clientX : t.clientX - d.left, I = e.vertical ? d.height : d.width, W = h / I;
      return m + W * (k - m);
    },
    [
      w,
      e.vertical,
      f,
      m,
      k,
      x.start,
      x.end,
      e.value && e.value.start,
      e.value && e.value.end
    ]
  ), B = a.useCallback(
    (t) => t <= c.start ? "start" : t >= c.end ? "end" : 2 * t < c.end + c.start ? "start" : "end",
    [
      x.start,
      x.end,
      e.value && e.value.start,
      e.value && e.value.end
    ]
  ), G = a.useCallback(
    (t) => {
      switch (t.keyCode) {
        case p.right:
          t.preventDefault(), i({ type: f === "rtl" ? n.decrease : n.increase, key: "start", event: t });
          break;
        case p.up:
          t.preventDefault(), i({ type: n.increase, key: "start", event: t });
          break;
        case p.left:
          t.preventDefault(), i({ type: f === "rtl" ? n.increase : n.decrease, key: "start", event: t });
          break;
        case p.down:
          t.preventDefault(), i({ type: n.decrease, key: "start", event: t });
          break;
        case p.home:
          t.preventDefault(), i({ type: n.min, key: "start", event: t });
          break;
        case p.end:
          t.preventDefault(), i({ type: n.max, key: "start", event: t });
          break;
      }
    },
    [i]
  ), O = a.useCallback(
    (t) => {
      switch (t.keyCode) {
        case p.right:
          t.preventDefault(), i({ type: f === "rtl" ? n.decrease : n.increase, key: "end", event: t });
          break;
        case p.up:
          t.preventDefault(), i({ type: n.increase, key: "end", event: t });
          break;
        case p.left:
          t.preventDefault(), i({ type: f === "rtl" ? n.increase : n.decrease, key: "end", event: t });
          break;
        case p.down:
          t.preventDefault(), i({ type: n.decrease, key: "end", event: t });
          break;
        case p.home:
          t.preventDefault(), i({ type: n.min, key: "end", event: t });
          break;
        case p.end:
          t.preventDefault(), i({ type: n.max, key: "end", event: t });
          break;
      }
    },
    [i, f]
  ), X = a.useCallback(
    (t) => {
      const d = C(t), h = B(d);
      S(h), h === "end" ? T.current.focus() : b.current.focus();
      const I = h === "end" ? n.end : n.start;
      i({ type: I, payload: d, event: t });
    },
    [e.vertical, m, k, i]
  );
  return J(w, { onPress: X, onDrag: (t) => {
    const d = C(t), h = E === "end" ? n.end : n.start;
    i({ type: h, payload: d, event: t });
  }, onRelease: (t) => {
    const d = C(t), h = E === "end" ? n.end : n.start;
    i({ type: h, payload: d, event: t }), S("");
  } }), /* @__PURE__ */ a.createElement(
    "div",
    {
      id: e.id,
      style: e.style,
      ref: o,
      dir: f,
      className: Q(
        "k-slider",
        {
          "k-rtl": f === "rtl",
          "k-disabled": e.disabled,
          "k-slider-vertical": e.vertical,
          "k-slider-horizontal": !e.vertical
        },
        e.className
      )
    },
    /* @__PURE__ */ a.createElement(
      "div",
      {
        ref: w,
        className: "k-slider-track-wrap",
        style: {
          flexGrow: 1,
          position: "relative",
          touchAction: "none",
          ...q
        }
      },
      e.children && /* @__PURE__ */ a.createElement(
        "ul",
        {
          className: "k-reset k-slider-items",
          style: { ...N }
        },
        a.Children.map(e.children, (t, d) => t && a.cloneElement(
          t,
          {
            position: 100 * (t.props.position - e.min) / (e.max - e.min),
            vertical: e.vertical,
            firstTick: d === 0,
            lastTick: d === a.Children.count(e.children) - 1
          },
          t.props.children
        ))
      ),
      /* @__PURE__ */ a.createElement(
        "div",
        {
          ref: L,
          className: "k-slider-track",
          style: e.vertical ? { bottom: 0, height: "100%" } : { [f === "rtl" ? "right" : "left"]: 0, width: "100%" }
        },
        y !== null && D !== null && /* @__PURE__ */ a.createElement(
          "div",
          {
            "data-selection": !0,
            ref: v,
            title: `${c.start} - ${c.end}`,
            className: "k-slider-selection",
            style: e.vertical ? { height: D - y + "%", bottom: y + "%" } : {
              [f === "rtl" ? "right" : "left"]: y + "%",
              width: D - y + "%"
            }
          }
        ),
        /* @__PURE__ */ a.createElement(
          "span",
          {
            ref: b,
            role: "slider",
            tabIndex: V(e.startTabIndex, e.disabled, void 0),
            "aria-valuemin": m,
            "aria-valuemax": Math.max(k, c.end),
            "aria-valuenow": c.start,
            "aria-disabled": e.disabled ? "true" : void 0,
            "aria-valuetext": `${c.start} - ${c.end}`,
            className: "k-draghandle k-draghandle-start",
            title: M.toLanguageString($, z[$]),
            style: e.vertical ? { bottom: "calc(" + y + "%)", zIndex: 1 } : f === "rtl" ? { right: "calc(" + y + "% - 13px)", zIndex: 1 } : { left: "calc(" + y + "%)", zIndex: 1 },
            onKeyDown: G
          }
        ),
        /* @__PURE__ */ a.createElement(
          "span",
          {
            ref: T,
            role: "slider",
            tabIndex: V(e.endTabIndex, e.disabled, void 0),
            "aria-valuemin": Math.min(m, c.start),
            "aria-valuemax": k,
            "aria-valuenow": c.end,
            "aria-disabled": e.disabled ? "true" : void 0,
            "aria-valuetext": `${c.start} - ${c.end}`,
            className: "k-draghandle k-draghandle-end",
            title: M.toLanguageString($, z[$]),
            style: e.vertical ? { bottom: "calc(" + D + "%)", zIndex: 1 } : f === "rtl" ? { right: "calc(" + D + "% - 13px)", zIndex: 1 } : { left: "calc(" + D + "%)", zIndex: 1 },
            onKeyDown: O
          }
        )
      )
    )
  );
}), re = {
  value: (r, l, u) => {
    if (r.value) {
      const e = r.value.start, s = r.value.end, o = r.min, v = r.max;
      if (e > s || e > v || e < o || s > v || s < o || s < e)
        return new Error(
          `Invalid prop + ${l} supplied to ${u}.
                    The { start, end } value must be between the min & max value and { start, end } must be start < end.
                    `
        );
    }
    return null;
  },
  defaultValue: (r, l, u) => {
    if (r.defaultValue) {
      const e = r.defaultValue.start, s = r.defaultValue.end, o = r.min, v = r.max;
      if (e > s || e > v || e < o || s > v || s < o || s < e)
        return new Error(
          `Invalid prop + ${l} supplied to ${u}.
                    The { start, end } value must be between the min & max value and { start, end } must be start < end.
                    `
        );
    }
    return null;
  },
  onChange: R.func,
  step: R.number,
  min: (r, l, u) => {
    const e = r[l], s = r.min, o = r.max;
    return s === void 0 ? new Error(
      `Invalid prop + ${l} supplied to ${u}.
                ${l} value can not be undefined.
                `
    ) : e && s >= o ? new Error(
      `Invalid prop + ${l} supplied to ${u}.
                ${l} value can not be equal to or bigger than the max value.
                `
    ) : null;
  },
  max: (r, l, u) => {
    const e = r[l], s = r.min, o = r.max;
    return o === void 0 ? new Error(
      `Invalid prop + ${l} supplied to ${u}.
                ${l} value can not be undefined.
                `
    ) : e && o <= s ? new Error(
      `Invalid prop + ${l} supplied to ${u}.
                ${l} value can not be equal to or smaller than the min value.
                `
    ) : null;
  },
  vertical: R.bool,
  disabled: R.bool,
  dir: R.oneOf(["ltr", "rtl"])
}, g = {
  step: 1,
  defaultValue: {
    start: 0,
    end: 0
  },
  vertical: !1,
  disabled: !1
};
P.displayName = "KendoReactRangeSlider";
P.propTypes = re;
export {
  P as RangeSlider,
  ae as RangeSliderPropsContext
};
