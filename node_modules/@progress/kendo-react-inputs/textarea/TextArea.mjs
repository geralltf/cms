/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as t from "react";
import e from "prop-types";
import { createPropsContext as se, usePropsContext as ie, useCustomComponent as M, useId as ue, useDir as de, useIsomorphicLayoutEffect as ce, dispatchEvent as h, classNames as O, getTabIndex as fe, kendoThemeMaps as S } from "@progress/kendo-react-common";
const me = se(), w = t.forwardRef((A, N) => {
  const l = ie(me, A), {
    size: u = y.size,
    rounded: d = y.rounded,
    fillMode: k = y.fillMode,
    prefix: H = null,
    suffix: F = null,
    ariaDescribedBy: R,
    ariaLabelledBy: $,
    autoSize: C,
    className: D,
    defaultValue: L,
    disabled: r,
    readOnly: q,
    required: c,
    rows: j,
    id: K,
    name: G,
    placeholder: J,
    style: Q,
    tabIndex: U,
    value: f,
    valid: z,
    validationMessage: I,
    validityStyles: P,
    onChange: m,
    onFocus: p,
    onBlur: b,
    // Removed to support direct use in Form Field component
    visited: pe,
    touched: be,
    modified: xe,
    resizable: x,
    ...W
  } = l, a = t.useRef(null), T = t.useCallback(
    () => {
      a.current && a.current.focus();
    },
    []
  ), [V, B] = t.useState(L), [X, Y] = M(H), [Z, _] = M(F), o = f !== void 0, s = o ? f : V, i = t.useCallback(
    () => ({
      element: a,
      focus: T,
      get value() {
        return s;
      },
      get name() {
        return a.current && a.current.name;
      }
    }),
    [T, s]
  );
  t.useImperativeHandle(N, i);
  const [ee, E] = t.useState("auto"), te = ue(), ae = de(a, l.dir), g = z !== void 0 ? z : c ? !!s : !0;
  t.useEffect(
    () => {
      a.current && a.current.setCustomValidity && a.current.setCustomValidity(
        g ? "" : I || ""
      );
    },
    [g, I]
  ), ce(
    () => {
      a.current && E(`${a.current.scrollHeight}px`);
    },
    [s]
  );
  const re = t.useCallback(
    (n) => {
      const v = n.target.value;
      E("auto"), !o && !r && B(v), m && !r && h(
        m,
        n,
        {
          ...i(),
          value: v
        },
        { value: v }
      );
    },
    [B, m, r, o]
  ), ne = t.useCallback(
    (n) => {
      p && !r && h(
        p,
        n,
        i(),
        void 0
      );
    },
    [p, r]
  ), le = t.useCallback(
    (n) => {
      b && !r && h(
        b,
        n,
        i(),
        void 0
      );
    },
    [b, r]
  ), oe = {
    id: K || te,
    role: "textbox",
    name: G,
    className: O("k-input-inner", "!k-overflow-auto", { "k-resize": !C && x !== "none" }),
    ref: a,
    disabled: r,
    rows: j,
    placeholder: J,
    readOnly: q,
    required: c,
    tabIndex: fe(U, r),
    style: C ? { resize: "none", overflow: "hidden", height: ee } : x ? { resize: x } : {},
    "aria-labelledby": $,
    "aria-describedby": R,
    "aria-multiline": !0,
    "aria-disabled": r || void 0,
    value: o ? f : V,
    ...W,
    onChange: re,
    onFocus: ne,
    onBlur: le
  };
  return /* @__PURE__ */ t.createElement(
    "span",
    {
      className: O(
        "k-input",
        "k-textarea",
        {
          [`k-input-${S.sizeMap[u] || u}`]: u,
          [`k-input-${k}`]: k,
          [`k-rounded-${S.roundedMap[d] || d}`]: d,
          "k-invalid": !(g || P !== void 0 || P === !0),
          "k-required": c,
          "k-disabled": r
        },
        D
      ),
      style: Q,
      dir: ae
    },
    l.prefix && /* @__PURE__ */ t.createElement(X, { ...Y }),
    /* @__PURE__ */ t.createElement("textarea", { ...oe }),
    l.suffix && /* @__PURE__ */ t.createElement(Z, { ..._ })
  );
});
w.propTypes = {
  ariaDescribedBy: e.string,
  ariaLabelledBy: e.string,
  autoSize: e.bool,
  className: e.string,
  defaultValue: e.string,
  dir: e.string,
  disabled: e.bool,
  readOnly: e.bool,
  rows: e.number,
  id: e.string,
  name: e.string,
  placeholder: e.string,
  style: e.object,
  tabIndex: e.number,
  value: e.oneOfType([
    e.string,
    e.arrayOf(e.string),
    e.number
  ]),
  onChange: e.func,
  onFocus: e.func,
  onBlur: e.func,
  size: e.oneOf([null, "small", "medium", "large"]),
  rounded: e.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: e.oneOf([null, "solid", "flat", "outline"]),
  resizable: e.oneOf(["none", "both", "horizontal", "vertical"])
};
const y = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid"
};
w.displayName = "KendoTextArea";
export {
  w as TextArea,
  me as TextAreaPropsContext
};
