/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { sequence as i, greedy as k } from "./parsing/combinators.mjs";
import { literal as d, mask as T, unliteral as p, unmask as f, rawLiteral as m, rawMask as c, token as u } from "./parsing/parsers.mjs";
class C {
  constructor() {
    this.rules = {}, this.prompt = "_", this.mask = "", this.promptPlaceholder = " ", this.includeLiterals = !1, this.maskTokens = [], this.unmaskTokens = [], this.rawTokens = [], this.validationTokens = [];
  }
  update({ mask: e = "", prompt: s = "", promptPlaceholder: t = " ", rules: r = {}, includeLiterals: n = !1 }) {
    this.mask = e, this.prompt = s, this.promptPlaceholder = t, this.rules = r, this.includeLiterals = n, this.tokenize();
  }
  validationValue(e = "") {
    let s = e;
    return i(this.validationTokens).run(e).fold((t) => {
      s = t.join("");
    }), s;
  }
  rawValue(e = "") {
    let s = e;
    return this.rawTokens.length && i(this.rawTokens).run(e).fold((t) => {
      s = t.join("");
    }), s;
  }
  /**
   * @hidden
   */
  maskRaw(e = "") {
    let s = e;
    return this.maskTokens.length && i(this.maskTokens).run(e).fold((t) => {
      s = t.join("");
    }), s;
  }
  maskInput(e, s, t) {
    return e.length < s.length ? this.maskRemoved(e, s, t) : this.maskInserted(e, s, t);
  }
  maskInRange(e, s, t, r) {
    let n = "", o = r;
    const a = s.split("").slice(0, t), l = s.split("").slice(r);
    return i(this.maskTokens.slice(t, r)).run(e).fold((h) => {
      n = a.concat(h).concat(l).join("");
    }), {
      selection: o,
      value: n
    };
  }
  maskRemoved(e, s, t) {
    let r = "", n = t;
    const o = e.split("").slice(t), a = e.split("").slice(0, t).join(""), l = this.maskTokens.length - (e.length - t);
    return i(this.maskTokens.slice(0, l)).run(a, s).fold((h) => {
      n = this.adjustPosition(h, n), r = h.concat(o).join("");
    }), {
      selection: n,
      value: r
    };
  }
  adjustPosition(e, s) {
    const t = e[s];
    return !this.maskTokens[s].isLiteral(t) && t !== this.prompt ? s + 1 : s;
  }
  maskInserted(e, s, t) {
    let r = "", n = t;
    const o = e.slice(0, t);
    return i(this.unmaskTokens).run(o, s).chain((a) => {
      n = a.join("").length;
      const l = s.slice(n);
      return i(this.maskTokens).run(a.join("") + l, s);
    }).fold((a) => {
      r = a.join("");
    }), {
      selection: n,
      value: r
    };
  }
  get maskTokenCreator() {
    const { prompt: e, promptPlaceholder: s } = this;
    return {
      literal: (t) => d(t),
      mask: (t) => T({ prompt: e, promptPlaceholder: s })(t)
    };
  }
  get unmaskTokenCreator() {
    return {
      literal: (e) => p(e),
      mask: (e) => f(this.prompt)(e)
    };
  }
  get rawTokenCreator() {
    const { prompt: e, promptPlaceholder: s, includeLiterals: t } = this;
    return {
      literal: (r) => m(t),
      mask: (r) => c({ prompt: e, promptPlaceholder: s })
    };
  }
  get validationTokenCreator() {
    const { prompt: e } = this;
    return {
      literal: (s) => m(!1),
      mask: (s) => c({ prompt: e, promptPlaceholder: "" })
    };
  }
  tokenize() {
    k(u(this.rules, this.maskTokenCreator)).run(this.mask).fold((e, s) => {
      this.maskTokens = e;
    }), k(u(this.rules, this.unmaskTokenCreator)).run(this.mask).fold((e, s) => {
      this.unmaskTokens = e;
    }), k(u(this.rules, this.rawTokenCreator)).run(this.mask).fold((e, s) => {
      this.rawTokens = e;
    }), k(u(this.rules, this.validationTokenCreator)).run(this.mask).fold((e, s) => {
      this.validationTokens = e;
    });
  }
}
export {
  C as MaskingService
};
