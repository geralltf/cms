/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { Result as i, ResultType as l } from "./result.mjs";
import { Stream as p } from "./stream.mjs";
const h = (t) => (t || "").split(""), a = "\\";
class u {
  constructor(e) {
    this.parse = e;
  }
  run(e, n = "") {
    return e instanceof p ? this.parse(e) : this.parse(new p(h(e), h(n)));
  }
  // map :: Functor f => f a ~> (a -> b) -> f b
  map(e) {
    return new u((n) => this.parse(n).map(e));
  }
  // chain :: Chain m => m a ~> (a -> m b) -> m b
  chain(e) {
    return new u((n) => this.parse(n).chain((r, c) => e(r).run(c)));
  }
  isLiteral(e) {
    return this.run(e).type === l.Literal;
  }
}
const k = (t) => (e) => new u((n) => {
  const { prompt: r, promptPlaceholder: c } = t;
  for (; !n.eof(); ) {
    const { char: o, control: w } = n.peek();
    if (o === w && w === r)
      return n.eat(), new i(r, n, l.Mask);
    if (e.test(o))
      return n.eat(), new i(o, n, l.Mask);
    if (o === c)
      return n.eat(), new i(r, n, l.Mask);
    n.eat_input();
  }
  return n.eat(), new i(r, n, l.Mask);
}), x = (t) => new u((e) => e.peek().char === t ? (e.eat(), new i(t, e, l.Literal)) : new i(t, e, l.Literal)), L = (t) => (e) => new u((n) => {
  for (; !n.eof(); ) {
    const { char: r, control: c } = n.peek();
    if (r === t && c === t)
      return n.eat(), new i(r, n);
    if (e.test(r))
      return n.eat(), new i(r, n);
    n.eat_input();
  }
  return n.eat(), new i("", n);
}), M = (t) => new u((e) => {
  if (e.eof())
    return new i("", e);
  const { char: n } = e.peek();
  return n === t && e.eat(), new i(t, e);
}), A = (t, e) => new u((n) => {
  let { char: r } = n.next();
  const c = t[r];
  return r === a ? (r = n.next().char, new i(e.literal(r), n)) : c ? new i(e.mask(c), n) : new i(e.literal(r), n);
}), R = (t) => new u((e) => {
  const { prompt: n, promptPlaceholder: r } = t;
  let { char: c } = e.next();
  return c === n ? new i(r, e) : new i(c, e);
}), y = (t) => new u((e) => {
  let { char: n } = e.next();
  return t ? new i(n, e) : new i("", e);
});
export {
  u as Parser,
  x as literal,
  k as mask,
  y as rawLiteral,
  R as rawMask,
  A as token,
  M as unliteral,
  L as unmask
};
