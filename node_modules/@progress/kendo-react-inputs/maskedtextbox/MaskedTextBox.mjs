/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as p from "react";
import e from "prop-types";
import { MaskingService as k } from "./masking.service.mjs";
import { defaultRules as v, maskingChanged as P, returnFalse as m } from "./utils.mjs";
import { validatePackage as _, useCustomComponent as g, classNames as C, kendoThemeMaps as y, getTabIndex as S, createPropsContext as x, withIdHOC as E, withPropsContext as V } from "@progress/kendo-react-common";
import { FloatingLabel as O } from "@progress/kendo-react-labels";
import { packageMetadata as M } from "../package-metadata.mjs";
const l = class l extends p.Component {
  constructor(s) {
    super(s), this.state = {}, this._inputId = `k-${this.props.id}`, this._service = new k(), this._isPasted = !1, this._selection = [null, null], this._input = null, this.focus = () => {
      this._input && this._input.focus();
    }, this.pasteHandler = (t) => {
      const { selectionStart: r, selectionEnd: i } = t.target;
      i !== r && (this._isPasted = !0, this._selection = [r || 0, i || 0]);
    }, this.onChangeHandler = (t) => {
      const r = t.currentTarget, i = r.value, n = this._selection[0] || 0, a = this._selection[1] || 0;
      if (!this.props.mask) {
        this._isPasted = !1, this._selection = [null, null], this.triggerOnChange(i, t);
        return;
      }
      const d = this.value;
      let o;
      if (this._isPasted) {
        this._isPasted = !1;
        const u = d.length - a, h = i.length - u;
        o = this._service.maskInRange(i.slice(n, h), d, n, a);
      } else
        o = this._service.maskInput(i, d, r.selectionStart || 0);
      this._selection = [o.selection, o.selection], this.triggerOnChange(o.value, t);
    }, this.focusHandler = (t) => {
      this.state.focused || (this.setState({ focused: !0 }), this.props.onFocus && this.props.onFocus.call(void 0, {
        target: this,
        syntheticEvent: t,
        nativeEvent: t.nativeEvent
      }));
    }, this.blurHandler = (t) => {
      this.state.focused && (this.setState({ focused: !1 }), this.props.onBlur && this.props.onBlur.call(void 0, {
        target: this,
        syntheticEvent: t,
        nativeEvent: t.nativeEvent
      }));
    }, this.setValidity = () => {
      this.element && this.element.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || ""
      );
    }, _(M);
  }
  /**
   * Gets the element of the MaskedTextBox.
   *
   * @return - An `HTMLInputElement`.
   *
   * @example
   * ```jsx
   * class App extends React.Component {
   *     constructor(props) {
   *         super(props);
   *     }
   *     element = null;
   *     render() {
   *         return (
   *             <div>
   *                 <MaskedTextBox
   *                     ref={(component) =>
   *                         this.element = component ? component.element : null}
   *                 />
   *                 <button onClick={() => console.log(this.element)}>console.log the element</button>
   *             </div>
   *         );
   *     }
   * }
   *
   * ReactDOM.render(
   *     <App />,
   *     document.getElementsByTagName('my-app')[0]
   * );
   * ```
   */
  get element() {
    return this._input;
  }
  /**
   * Gets the value with the mask of the MaskedTextBox.
   */
  get value() {
    return this._valueDuringOnChange !== void 0 ? this._valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value !== void 0 ? this.state.value : this.props.defaultValue !== void 0 ? this.props.defaultValue : "";
  }
  /**
   * Gets the raw value without the mask of the MaskedTextBox.
   */
  get rawValue() {
    return this._service.rawValue(this.value);
  }
  /**
   * Represents the validity state into which the MaskedTextBox is set.
   */
  get validity() {
    const s = this.value, t = this._service.validationValue(s), r = this.props.validationMessage !== void 0, i = this.props.valid !== void 0 ? this.props.valid : (!this.required || !!t) && (!this.props.maskValidation || !this.props.prompt || s.indexOf(this.props.prompt) === -1);
    return {
      customError: r,
      valid: i,
      valueMissing: !t
    };
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : l.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : l.defaultProps.required;
  }
  /**
   * Gets the `name` property of the MaskedTextBox.
   */
  get name() {
    return this.props.name;
  }
  /**
   * @hidden
   */
  componentDidUpdate(s, t) {
    if (this.element && this.state.focused && t.focused) {
      let [r, i] = this._selection;
      const n = s.selection, a = this.props.selection;
      (!n && a || n && a && (n.start !== a.start || n.end !== a.end)) && (r = a.start, i = a.end), r !== null && i !== null && this.element.setSelectionRange(r, i);
    }
    P(s, this.props) && this.updateService(), this.setValidity();
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.updateService(), this.setValidity();
  }
  /**
   * @hidden
   */
  render() {
    const {
      size: s = l.defaultProps.size,
      fillMode: t = l.defaultProps.fillMode,
      rounded: r = l.defaultProps.rounded
    } = this.props, i = this.props.id || this._inputId, n = !this.validityStyles || this.validity.valid, a = this.props.style || {}, {
      prefix: d = l.defaultProps.prefix,
      suffix: o = l.defaultProps.suffix
    } = this.props, [u] = g(d), [h] = g(o), f = /* @__PURE__ */ p.createElement(
      "span",
      {
        dir: this.props.dir,
        className: C(
          "k-maskedtextbox k-input",
          {
            [`k-input-${y.sizeMap[s] || s}`]: s,
            [`k-input-${t}`]: t,
            [`k-rounded-${y.roundedMap[r] || r}`]: r,
            "k-invalid": !n,
            "k-required": this.required,
            "k-disabled": this.props.disabled
          },
          this.props.className
        ),
        style: this.props.label ? a : { width: this.props.width, ...a }
      },
      /* @__PURE__ */ p.createElement(u, null),
      /* @__PURE__ */ p.createElement(
        "input",
        {
          type: "text",
          autoComplete: "off",
          autoCorrect: "off",
          autoCapitalize: "off",
          spellCheck: !1,
          className: "k-input-inner",
          value: this.value,
          id: i,
          "aria-labelledby": this.props.ariaLabelledBy,
          "aria-describedby": this.props.ariaDescribedBy,
          "aria-placeholder": this.props.mask,
          name: this.props.name,
          tabIndex: S(this.props.tabIndex, this.props.disabled, !0),
          accessKey: this.props.accessKey,
          title: this.props.title,
          disabled: this.props.disabled || void 0,
          readOnly: this.props.readonly || void 0,
          placeholder: this.props.placeholder,
          ref: (b) => this._input = b,
          onChange: this.onChangeHandler,
          onPaste: this.pasteHandler,
          onFocus: this.focusHandler,
          onBlur: this.blurHandler,
          onDragStart: m,
          onDrop: m
        }
      ),
      /* @__PURE__ */ p.createElement(h, null)
    );
    return this.props.label ? /* @__PURE__ */ p.createElement(
      O,
      {
        label: this.props.label,
        editorId: i,
        editorValue: this.value,
        editorValid: n,
        editorDisabled: this.props.disabled,
        editorPlaceholder: this.props.placeholder,
        children: f,
        style: { width: this.props.width },
        dir: this.props.dir
      }
    ) : f;
  }
  triggerOnChange(s, t) {
    if (this.setState({
      value: s
    }), this.props.onChange) {
      this._valueDuringOnChange = s;
      const r = {
        syntheticEvent: t,
        nativeEvent: t.nativeEvent,
        selectionStart: this._selection[0],
        selectionEnd: this._selection[1],
        target: this,
        value: this.value
      };
      this.props.onChange.call(void 0, r), this._valueDuringOnChange = void 0;
    }
  }
  updateService(s) {
    const t = Object.assign({
      includeLiterals: this.props.includeLiterals,
      mask: this.props.mask,
      prompt: this.props.prompt,
      promptPlaceholder: this.props.promptPlaceholder,
      rules: this.rules
    }, s);
    this._service.update(t);
  }
  get rules() {
    return Object.assign({}, v, this.props.rules);
  }
};
l.displayName = "MaskedTextBox", l.propTypes = {
  value: e.string,
  defaultValue: e.string,
  placeholder: e.string,
  title: e.string,
  dir: e.string,
  id: e.string,
  style: e.object,
  className: e.string,
  prefix: e.any,
  suffix: e.any,
  ariaLabelledBy: e.string,
  ariaDescribedBy: e.string,
  width: e.oneOfType([
    e.string,
    e.number
  ]),
  tabIndex: e.number,
  accessKey: e.string,
  disabled: e.bool,
  readonly: e.bool,
  prompt: e.string,
  promptPlaceholder: e.string,
  includeLiterals: e.bool,
  maskValidation: e.bool,
  mask: e.string,
  rules: function(s, t, r) {
    const i = s.rules;
    return i !== void 0 && !Object.entries(i).some((a) => typeof a != "string" || !(i[a] instanceof RegExp)) ? new Error(
      "Invalid prop `" + t + "` supplied to `" + r + "`. Validation failed."
    ) : null;
  },
  selection: e.shape({
    start: e.number.isRequired,
    end: e.number.isRequired
  }),
  name: e.string,
  label: e.string,
  validationMessage: e.string,
  required: e.bool,
  valid: e.bool,
  validityStyles: e.bool,
  onChange: e.func,
  size: e.oneOf([null, "small", "medium", "large"]),
  rounded: e.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: e.oneOf([null, "solid", "flat", "outline"])
}, l.defaultProps = {
  prompt: "_",
  promptPlaceholder: " ",
  includeLiterals: !1,
  maskValidation: !0,
  rules: v,
  required: !1,
  validityStyles: !0,
  prefix: (s) => null,
  suffix: (s) => null,
  size: "medium",
  rounded: "medium",
  fillMode: "solid"
};
let c = l;
const I = x(), q = E(V(I, c));
q.displayName = "KendoReactMaskedTextBox";
export {
  q as MaskedTextBox,
  I as MaskedTextBoxPropsContext,
  c as MaskedTextBoxWithoutContext
};
