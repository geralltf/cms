/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as e from "react";
import n from "prop-types";
import { createPropsContext as se, validatePackage as ce, usePropsContext as ue, Keys as p, useDir as de, classNames as h, kendoThemeMaps as H, getTabIndex as pe, IconWrap as fe, svgIconPropType as me } from "@progress/kendo-react-common";
import { packageMetadata as ke } from "../package-metadata.mjs";
import { Picker as ve } from "./Picker.mjs";
import { ColorGradient as be } from "./ColorGradient.mjs";
import { ColorPalette as ge, DEFAULT_PRESET as Ee, DEFAULT_TILE_SIZE as Ce } from "./ColorPalette.mjs";
import { Button as ye } from "@progress/kendo-react-buttons";
import { caretAltDownIcon as Te } from "@progress/kendo-svg-icons";
import { colorPickerDropdownButtonAriaLabel as O, messages as Se } from "../messages/index.mjs";
import { useLocalization as we } from "@progress/kendo-react-intl";
const Ie = {
  opacity: !0
}, Pe = {
  palette: Ee,
  tileSize: Ce
}, L = (v) => v !== void 0, De = se(), z = e.forwardRef((v, M) => {
  ce(ke);
  const o = ue(De, v), V = we(), {
    size: b = f.size,
    rounded: g = f.rounded,
    fillMode: A = f.fillMode,
    gradientSettings: _ = f.gradientSettings,
    paletteSettings: K = f.paletteSettings,
    view: m = f.view,
    popupSettings: G,
    valid: U,
    disabled: E,
    tabIndex: $,
    icon: C,
    svgIcon: y,
    iconClassName: k,
    onChange: T,
    onFocus: S,
    onBlur: w,
    onActiveColorClick: I,
    className: W
  } = o, a = e.useRef(null), P = e.useRef(null), D = e.useRef(null), c = e.useRef(), Z = e.useRef(null), [j, x] = e.useState(!1), [q, J] = e.useState(o.defaultValue), [Q, X] = e.useState(!1), N = L(o.value), i = L(o.open), l = N ? o.value : q, u = i ? o.open : Q, B = e.useCallback(
    () => {
      a.current && a.current.focus();
    },
    []
  );
  e.useImperativeHandle(M, () => ({
    // we agreed that each element will have focus method exposed
    element: a.current,
    actionElement: Z.current,
    value: l,
    focus: B
  }), [l, B]);
  const s = e.useCallback(
    (t, d) => {
      i || (!t && !d && a && a.current && a.current.focus(), X(t));
    },
    [i]
  ), Y = e.useCallback(
    (t) => {
      const { altKey: d, keyCode: r } = t;
      if (r === p.esc) {
        s(!1);
        return;
      }
      if (r === p.enter && !i) {
        t.preventDefault(), t.stopPropagation(), s(!u);
        return;
      }
      d && (r === p.up || r === p.down) && (t.preventDefault(), t.stopPropagation(), r === p.up && a && a.current && (a.current.focus(), s(!1)), r === p.down && s(!0));
    },
    [u, i]
  ), ee = e.useCallback(
    () => {
      i || (P.current ? P.current.focus() : D.current && D.current.focus());
    },
    [i]
  ), te = e.useCallback(
    () => {
      s(!u, !0);
    },
    [u]
  ), ne = e.useCallback(
    (t) => {
      I && I.call(void 0, {
        syntheticEvent: t,
        nativeEvent: t.nativeEvent,
        value: l
      });
    },
    [I, l]
  ), oe = e.useCallback(
    (t) => {
      c.current ? (clearTimeout(c.current), c.current = void 0) : x(!0), S && S.call(void 0, {
        nativeEvent: t.nativeEvent,
        syntheticEvent: t
      });
    },
    [S]
  ), ae = e.useCallback(
    () => {
      s(!1, !0), x(!1), c.current = void 0;
    },
    []
  ), re = e.useCallback(
    (t) => {
      clearTimeout(c.current), c.current = window.setTimeout(ae), w && w.call(void 0, {
        nativeEvent: t.nativeEvent,
        syntheticEvent: t
      });
    },
    [w]
  ), R = e.useCallback(
    (t, d) => {
      const r = d ? t.rgbaValue : t.value;
      N || J(r), d && s(!1), T && T.call(void 0, {
        value: r,
        nativeEvent: t.nativeEvent,
        syntheticEvent: t.syntheticEvent
      });
    },
    [N, T]
  ), le = e.useCallback(
    (t) => R(t, !0),
    [L, R]
  ), F = de(a, o.dir), ie = U !== !1;
  return /* @__PURE__ */ e.createElement(
    "span",
    {
      id: o.id,
      role: "combobox",
      "aria-label": o.ariaLabel,
      "aria-labelledby": o.ariaLabelledBy,
      "aria-describedby": o.ariaDescribedBy,
      "aria-haspopup": "dialog",
      "aria-expanded": u,
      "aria-disabled": E ? "true" : void 0,
      className: h(
        "k-colorpicker",
        "k-picker",
        "k-icon-picker",
        {
          [`k-picker-${H.sizeMap[b] || b}`]: b,
          [`k-picker-${A}`]: A,
          [`k-rounded-${H.roundedMap[g] || g}`]: g,
          "k-invalid": !ie,
          "k-disabled": E,
          "k-focus": j,
          className: W
        }
      ),
      ref: a,
      tabIndex: pe($, E),
      title: o.title,
      onKeyDown: Y,
      onFocus: oe,
      onBlur: re,
      dir: F
    },
    /* @__PURE__ */ e.createElement(
      ve,
      {
        dir: F,
        open: u,
        onOpen: ee,
        popupAnchor: a.current || void 0,
        popupSettings: { ...G },
        input: /* @__PURE__ */ e.createElement("span", { onClick: ne, className: "k-input-inner" }, /* @__PURE__ */ e.createElement(
          "span",
          {
            className: h(
              "k-value-icon",
              "k-color-preview",
              {
                "k-no-color": !l,
                "k-icon-color-preview": C || y || k
              }
            )
          },
          k && /* @__PURE__ */ e.createElement("span", { className: h("k-color-preview-icon", k) }),
          !k && (C || y) && /* @__PURE__ */ e.createElement(fe, { name: C, icon: y }),
          /* @__PURE__ */ e.createElement("span", { className: "k-color-preview-mask", style: { backgroundColor: l } })
        )),
        button: /* @__PURE__ */ e.createElement(
          ye,
          {
            tabIndex: -1,
            type: "button",
            onClick: te,
            className: "k-input-button",
            rounded: null,
            icon: "caret-alt-down",
            svgIcon: Te,
            "aria-label": V.toLanguageString(O, Se[O])
          }
        ),
        content: /* @__PURE__ */ e.createElement(e.Fragment, null, (m === "combo" || m === "gradient") && /* @__PURE__ */ e.createElement(
          be,
          {
            ..._,
            tabIndex: 0,
            ref: P,
            value: l,
            onChange: R
          }
        ), (m === "combo" || m === "palette") && /* @__PURE__ */ e.createElement(
          ge,
          {
            ...K,
            ref: D,
            value: l,
            onChange: le
          }
        ))
      }
    )
  );
});
z.propTypes = {
  value: n.string,
  defaultValue: n.string,
  disabled: n.bool,
  view: n.oneOf(["gradient", "palette", "combo"]),
  dir: n.string,
  id: n.string,
  icon: n.string,
  svgIcon: me,
  ariaLabelledBy: n.string,
  ariaDescribedBy: n.string,
  size: n.oneOf([null, "small", "medium", "large"]),
  rounded: n.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: n.oneOf([null, "solid", "flat", "outline"]),
  className: n.string
};
const f = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  view: "palette",
  gradientSettings: Ie,
  paletteSettings: Pe
};
z.displayName = "KendoColorPicker";
export {
  z as ColorPicker,
  De as ColorPickerPropsContext
};
