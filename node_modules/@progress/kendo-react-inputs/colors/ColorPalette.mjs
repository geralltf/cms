/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as l from "react";
import s from "prop-types";
import { ColorPaletteService as E } from "./utils/color-palette.service.mjs";
import { Keys as a, validatePackage as k, classNames as m, getTabIndex as F, dispatchEvent as N, createPropsContext as P, withIdHOC as R, withPropsContext as T } from "@progress/kendo-react-common";
import { packageMetadata as I } from "../package-metadata.mjs";
import { PALETTEPRESETS as D } from "./models/palette-presets.mjs";
import { isPresent as L } from "./utils/misc.mjs";
import { parseColor as U } from "./utils/color-parser.mjs";
const x = 24, g = 10, z = "office", n = class n extends l.Component {
  constructor(t) {
    super(t), this.wrapper = null, this.paletteService = null, this.focus = () => {
      this.wrapper && this.wrapper.focus();
    }, this.onKeyDown = (e) => {
      switch (e.keyCode) {
        case a.down:
          this.handleCellNavigation(0, 1);
          break;
        case a.up:
          this.handleCellNavigation(0, -1);
          break;
        case a.right:
          this.handleCellNavigation(1, 0);
          break;
        case a.left:
          this.handleCellNavigation(-1, 0);
          break;
        case a.enter:
          this.handleEnter(e);
          break;
        default:
          return;
      }
      e.preventDefault();
    }, this.onColorClick = (e, o) => {
      this.isUncontrolled ? this.setState({ selectedColor: e, focusedColor: e }) : this.setState({ focusedColor: e }), this.dispatchChangeEvent(e, o);
    }, this.onFocus = (e) => {
      this.paletteService && (this.setState({ focusedColor: this.state.selectedColor || this.paletteService.colorRows[0][0] }), this.props.onFocus && this.props.onFocus.call(
        void 0,
        e
      ));
    }, this.onBlur = () => {
      this.setState({ focusedColor: void 0 });
    }, k(I), this.state = {
      selectedColor: this.props.value !== void 0 ? this.props.value : this.props.defaultValue ? this.props.defaultValue : void 0,
      isFirstRender: !0
    };
  }
  get guid() {
    return this.props.id;
  }
  /**
   * @hidden
   */
  render() {
    const t = this.getPaletteInfo(), e = this.paletteService = new E();
    e.setColorMatrix(t.colors, t.columns);
    const o = e.getCellCoordsFor(this.state.selectedColor), r = e.getCellCoordsFor(this.state.focusedColor), i = m("k-colorpalette", { "k-disabled": this.props.disabled }, this.props.className);
    return t.colors.length ? /* @__PURE__ */ l.createElement(
      "div",
      {
        id: this.props.id,
        role: "grid",
        className: i,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown,
        "aria-disabled": this.props.ariaDisabled || (this.props.disabled ? "true" : void 0),
        "aria-labelledby": this.props.ariaLabelledBy,
        "aria-describedby": this.props.ariaDescribedBy,
        tabIndex: F(this.props.tabIndex, this.props.disabled),
        ref: (d) => this.wrapper = d
      },
      /* @__PURE__ */ l.createElement("table", { className: "k-colorpalette-table", role: "presentation" }, /* @__PURE__ */ l.createElement("tbody", { role: "rowgroup" }, this.renderRows(e.colorRows, o, r)))
    ) : "";
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(t, e) {
    if (!e.isFirstRender && t.value !== void 0) {
      if (t.value === "" && e.selectedColor !== void 0)
        return { selectedColor: void 0 };
      if (t.value !== "" && t.value !== e.selectedColor)
        return { selectedColor: t.value };
    } else if (e.isFirstRender)
      return { isFirstRender: !1 };
    return null;
  }
  handleCellNavigation(t, e) {
    if (this.paletteService)
      if (this.focusedColorCooridanates) {
        const o = this.paletteService.getNextCell(
          this.focusedColorCooridanates,
          t,
          e
        );
        this.setState({ focusedColor: this.paletteService.getColorAt(o) });
      } else
        this.setState({ focusedColor: this.paletteService.colorRows[0][0] });
  }
  handleEnter(t) {
    this.isUncontrolled && this.setState({ selectedColor: this.state.focusedColor }), this.dispatchChangeEvent(this.state.focusedColor, t);
  }
  dispatchChangeEvent(t, e) {
    N(this.props.onChange, e, this, { value: t, rgbaValue: U(t, "rgba") });
  }
  get focusedColorCooridanates() {
    return this.state.focusedColor && this.paletteService ? this.paletteService.getCellCoordsFor(this.state.focusedColor) : void 0;
  }
  get isUncontrolled() {
    return this.props.value === void 0;
  }
  getPaletteInfo() {
    if (typeof this.props.palette == "string") {
      const t = D[this.props.palette];
      return L(t) ? {
        colors: t.colors,
        columns: this.props.columns || t.columns || g
      } : { colors: [], columns: 0 };
    } else
      return { colors: this.props.palette || [], columns: this.props.columns || g };
  }
  renderRows(t, e, o) {
    return t.map((r, i) => /* @__PURE__ */ l.createElement("tr", { role: "row", key: i }, this.renderColumns(r, i, e, o)));
  }
  renderColumns(t, e, o, r) {
    const i = o !== void 0 && o.row === e, d = o && o.col, v = r !== void 0 && r.row === e, b = r && r.col, u = typeof this.props.tileSize != "number" ? this.props.tileSize : { width: this.props.tileSize, height: this.props.tileSize }, f = u.width + "px", S = u.height + "px";
    return t.map((p, c) => {
      const C = i && d === c, w = m(
        "k-colorpalette-tile",
        {
          "k-selected": C,
          "k-focus": v && b === c
        }
      );
      return /* @__PURE__ */ l.createElement(
        "td",
        {
          role: "gridcell",
          className: w,
          "aria-label": p,
          "aria-selected": C ? !0 : this.props.disabled ? void 0 : !1,
          style: { backgroundColor: p, width: f, height: S, minWidth: f },
          onClick: (y) => this.onColorClick(p, y),
          id: this.createCellId({ row: e, col: c }),
          key: c
        }
      );
    });
  }
  createCellId(t) {
    return `${this.guid}_${t.row}_${t.col}`;
  }
};
n.displayName = "ColorPalette", n.propTypes = {
  palette: s.oneOfType([s.arrayOf(s.string.isRequired), s.string]),
  columns: s.number,
  tileSize: s.any,
  defaultValue: s.string,
  value: s.string,
  disabled: s.bool,
  tabIndex: s.number,
  onChange: s.func,
  onFocus: s.func,
  id: s.string,
  ariaLabelledBy: s.string,
  ariaDescribedBy: s.string,
  className: s.string
}, n.defaultProps = {
  palette: z,
  tileSize: x
};
let h = n;
const B = P(), A = R(T(B, h));
A.displayName = "KendoReactColorPalette";
export {
  A as ColorPalette,
  B as ColorPalettePropsContext,
  h as ColorPaletteWithoutContext,
  g as DEFAULT_COLUMNS_COUNT,
  z as DEFAULT_PRESET,
  x as DEFAULT_TILE_SIZE
};
