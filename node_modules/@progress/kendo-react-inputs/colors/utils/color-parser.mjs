/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { parseColor as u, Color as m } from "@progress/kendo-drawing";
import { isPresent as c, fitIntoBounds as s } from "./misc.mjs";
const B = (t, r, o = !0) => {
  if (["hex", "rgba"].indexOf(r) === -1)
    throw new Error(`Unsupported color output format '${r}'. The available options are 'hex' or 'rgba'.`);
  if (!c(t))
    return;
  const n = u(t.trim(), o);
  if (c(n))
    return r === "hex" ? n.toCss() : n.toCssRgba();
}, R = (t, r = !0) => {
  const o = u(t, r);
  return c(o) ? o.toHSV() : {};
}, F = (t, r = !0) => {
  const o = u(t, r);
  return c(o) ? o.toBytes() : {};
}, C = (t) => {
  const r = s(t.h, 0, 359.9), o = s(t.s, 0, 1), e = s(t.v, 0, 1), n = s(t.a, 0, 1);
  return m.fromHSV(r, o, e, n).toCssRgba();
}, w = (t) => C({ h: t, s: 1, v: 1, a: 1 }), x = (t) => {
  const r = s(t.r, 0, 255), o = s(t.g, 0, 255), e = s(t.b, 0, 255), n = s(t.a, 0, 1);
  return m.fromBytes(r, o, e, n).toCssRgba();
}, i = (t, r) => {
  const o = s(t.r, 0, 255), e = s(t.g, 0, 255), n = s(t.b, 0, 255), a = s(t.a, 0, 1), g = s(r.r, 0, 255), h = s(r.g, 0, 255), l = s(r.b, 0, 255);
  return {
    r: Math.round((1 - a) * g + a * o),
    g: Math.round((1 - a) * h + a * e),
    b: Math.round((1 - a) * l + a * n)
  };
}, p = (t) => {
  let r = [t.r || 0, t.g || 0, t.b || 0].map(function(o) {
    return o /= 255, o <= 0.03928 ? o / 12.92 : Math.pow((o + 0.055) / 1.055, 2.4);
  });
  return r[0] * 0.2126 + r[1] * 0.7152 + r[2] * 0.0722;
}, b = (t, r) => {
  const o = Math.max(t, r), e = Math.min(t, r);
  return (o + 0.05) / (e + 0.05);
}, M = (t, r) => b(
  p(i(t, r)),
  p(i(r, { r: 0, g: 0, b: 0, a: 1 }))
);
export {
  C as getColorFromHSV,
  w as getColorFromHue,
  x as getColorFromRGBA,
  b as getContrast,
  M as getContrastFromTwoRGBAs,
  R as getHSV,
  p as getLuminance,
  F as getRGBA,
  i as getRGBFromRGBA,
  B as parseColor
};
