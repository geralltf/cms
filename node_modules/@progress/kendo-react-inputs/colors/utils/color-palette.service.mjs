/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { isPresent as e } from "./misc.mjs";
import { parseColor as n } from "@progress/kendo-drawing";
class f {
  constructor() {
    this.colorRows = [];
  }
  setColorMatrix(o, r) {
    if (this.colorRows = [], !!(e(o) && o.length)) {
      r = r || o.length;
      for (let t = 0; t < o.length; t += r) {
        const s = o.slice(t, r + t);
        this.colorRows.push(s);
      }
    }
  }
  getCellCoordsFor(o) {
    if (!e(o))
      return;
    const r = o && n(o, !0), t = [o];
    e(r) && t.push(r.toCss(), r.toCssRgba());
    for (let s = 0; s < this.colorRows.length; s++)
      for (let i = 0; i < this.colorRows[s].length; i++)
        if (t.some((l) => l === this.colorRows[s][i]))
          return { row: s, col: i };
  }
  getColorAt(o) {
    if (e(o) && e(this.colorRows[o.row]))
      return this.colorRows[o.row][o.col];
  }
  getNextCell(o, r, t) {
    if (!(e(o) && e(o.row) && e(o.col)))
      return { row: 0, col: 0 };
    const s = this.clampIndex(o.row + t, this.colorRows.length - 1), i = this.clampIndex(o.col + r, this.colorRows[s].length - 1);
    return { row: s, col: i };
  }
  clampIndex(o, r) {
    return o < 0 ? 0 : o > r ? r : o;
  }
}
export {
  f as ColorPaletteService
};
