/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright © 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
const M = 11111111111111e-7, ae = 0.31111111111111117, de = 1, Y = 1, w = 0, m = /\d/, ee = 15, Ie = () => ({
  eventValue: null,
  prevLooseValue: "",
  currentLooseValue: "",
  focused: !1,
  selectionStart: void 0,
  selectionEnd: void 0,
  decimalSelect: !1,
  valueIsCorrected: !1,
  valueIsOutOfRange: !1
}), Ne = (t, n) => t !== void 0 ? t : n, p = (t, n, r) => t === null && t === void 0 ? "" : typeof t == "string" ? t : r.formatNumber(t, n), J = (t) => (String(t).split(".")[1] || "").length, ne = (t, n) => Math.max(J(t), J(n)), ge = (t) => Math.min(t, ee), te = (t, n) => {
  const r = ge(n);
  return parseFloat(t.toFixed(r));
}, Ce = (t, n, r, e, u, o, a) => {
  const s = ne(t || 0, r || 0), l = re(te((t || 0) + (r || 0), s), e, u);
  n.eventValue = l, n.currentLooseValue = p(l, o, a), n.selectionStart = n.selectionEnd = O(n.currentLooseValue, m);
}, Ee = (t, n, r, e, u, o, a) => {
  const s = ne(t || 0, r || 0), l = re(te((t || 0) - (r || 0), s), e, u);
  n.eventValue = l, n.currentLooseValue = p(l, o, a), n.selectionStart = n.selectionEnd = O(n.currentLooseValue, m);
}, re = (t, n, r) => t == null ? t : !(t > 1 || t < 1 || t === 1) || r !== void 0 && n !== void 0 && r < n ? null : (r !== void 0 && t > r && (t = r), n !== void 0 && t < n && (t = n), t), fe = (t, n) => {
  const r = n.findIndex(([u, o]) => !!o && t.indexOf(o) === t.length - o.length);
  if (r === -1)
    return -1;
  const e = n[r][1];
  return t.length - e.length;
}, me = (t, n) => {
  const r = n.findIndex(([u, o]) => !!u && t.indexOf(u) === 0);
  return r === -1 ? -1 : n[r][0].length;
}, Ve = (t, n, r) => {
  const e = fe(t, n);
  if (e !== -1 && r.selectionStart > e) {
    r.selectionStart = r.selectionEnd = e;
    return;
  }
  r.selectionStart > t.length && (r.selectionStart = r.selectionEnd = t.length);
  const u = me(t, n);
  u !== -1 && r.selectionStart < u && (r.selectionStart = r.selectionEnd = u), r.selectionStart === -1 && (r.selectionStart = r.selectionEnd = 0);
}, L = (t, n, r, e) => {
  t.selectionStart = t.selectionEnd = n, Ve(r, e, t);
}, A = (t, n, r, e) => {
  t.eventValue = e.parseNumber(t.prevLooseValue, n), t.currentLooseValue = t.prevLooseValue, t.valueIsCorrected = !0, L(t, t.selectionStart, t.currentLooseValue, r);
}, _ = (t, n, r) => n.split(t).length !== r.split(t).length && n.length === r.length + t.length, pe = (t, n) => {
  const r = String(t.currentLooseValue), e = String(t.prevLooseValue);
  return _(n.minusSign, r, e) || _("-", r, e) || _("−", r, e);
}, xe = (t, n) => {
  const r = String(t.currentLooseValue), e = String(t.prevLooseValue);
  return r.indexOf(n.minusSign) === -1 && e.indexOf(n.minusSign) !== -1;
}, Le = (t, n) => String(t.currentLooseValue).split(n.decimal).length > 2, be = (t, n) => {
  const r = n.formatNumber(M, t), e = n.formatNumber(-M, t), u = n.formatNumber(w, t), o = n.formatNumber(Y, t), a = D(r), s = D(e), l = D(u), i = D(o), N = P(r), C = P(e), x = P(u), b = P(o);
  return {
    positiveInfo: [a, N],
    negativeInfo: [s, C],
    zeroInfo: [l, x],
    oneInfo: [i, b]
  };
}, he = (t, n) => {
  const r = n.formatNumber(M, t), e = n.formatNumber(-M, t), u = n.formatNumber(w, t), o = n.formatNumber(Y, t), a = n.numberSymbols(), s = new RegExp(`[\\d\\${a.decimal}${a.group}]`, "g");
  return [r, e, u, o].map((i) => i.replace(s, "")).join("").split("").filter((i, N, C) => C.indexOf(i) === N).join("");
}, B = (t, n) => {
  const r = t.indexOf(n.decimal);
  return r > -1 ? r : O(t, m);
}, T = (t) => t.split("").reverse().join(""), O = (t, n) => t.length - T(t).search(n), D = (t) => t.split(t[t.search(m)])[0], P = (t) => {
  const n = T(t);
  return T(n.split(n[n.search(m)])[0]);
}, $ = (t, n) => t.search(n), K = (t, n) => {
  const r = t.indexOf(n);
  return r > -1 ? t.length - r - 1 : 0;
}, Q = (t, n, r, e, u) => {
  const o = t.replace(u, "")[0] === "0", a = n.replace(u, "")[0] === "0";
  if (o && !a)
    return r - 1;
  if (a && e)
    return r + 1;
  let s = 0;
  for (let i = 0; i < r; i++)
    m.test(t.charAt(i)) && s++;
  let l = 0;
  for (; s > 0 && n.length > l; )
    m.test(n.charAt(l)) && s--, l++;
  return l;
}, Oe = (t, n, r) => {
  const e = { ...t }, { prevLooseValue: u } = e, o = r.numberSymbols(), a = he(n, r), s = String(e.currentLooseValue), l = String(u), i = new RegExp(`[^\\d\\${o.decimal}]`, "g"), N = new RegExp(`[^\\d\\${o.decimal}\\${o.group}]`, "g"), C = new RegExp(`[\\d\\${o.decimal}\\${o.group}]`), x = s.replace(i, ""), b = $(s, m), E = b === -1 ? -1 : O(s, m), oe = s.indexOf(o.decimal), G = (s.substring(0, b) + s.substring(b, E).replace(N, "") + s.substring(E, s.length)).split("").filter((V) => a.indexOf(V) !== -1 || V.search(C) !== -1).join(""), S = r.formatNumber(ae, n).replace(i, ""), U = S.indexOf(o.decimal), I = U > -1 ? S.length - U - 1 : 0, j = r.formatNumber(de, n).replace(i, ""), X = j.indexOf(o.decimal), R = X > -1 ? j.length - X - 1 : 0, {
    positiveInfo: se,
    negativeInfo: ue,
    zeroInfo: ce,
    oneInfo: le
  } = be(n, r), g = [se, ue, ce, le], ie = g.findIndex((V) => V.findIndex((h) => !!h) !== -1) !== 1, v = s.length > 0 && s.length < l.length, Z = typeof n == "string" && n[0] === "p" && s && s.indexOf(o.percentSign) === -1;
  if (!e.isPaste) {
    if (s === "")
      return e.eventValue = null, e.currentLooseValue = "", e;
    if (e.currentLooseValue === o.minusSign && r.formatNumber(-0, n) !== l)
      return e.eventValue = -0, e.currentLooseValue = p(e.eventValue, n, r), L(
        e,
        B(e.currentLooseValue, o),
        e.currentLooseValue,
        g
      ), e;
    if (e.currentLooseValue === o.decimal) {
      e.eventValue = 0;
      const f = p(e.eventValue, n, r);
      if (R === 0 && I > 0) {
        const c = O(f, m);
        e.currentLooseValue = f.substring(0, c) + o.decimal + f.substring(c);
      } else
        e.currentLooseValue = f;
      return L(
        e,
        B(e.currentLooseValue, o) + 1,
        e.currentLooseValue,
        g
      ), e;
    }
    if (pe(e, o)) {
      const f = r.parseNumber(u, n);
      e.eventValue = -(f !== null ? f : 0), e.currentLooseValue = p(e.eventValue, n, r);
      const c = $(e.currentLooseValue, m), d = $(l, m);
      return L(
        e,
        e.selectionEnd - 1 + (c - d),
        e.currentLooseValue,
        g
      ), e;
    }
    if (xe(e, o))
      return e.eventValue = r.parseNumber(e.currentLooseValue, n), L(
        e,
        e.selectionStart,
        e.currentLooseValue,
        g
      ), e;
    if (Le(e, o))
      return A(e, n, g, r), e;
    if (Z)
      return e.eventValue = r.parseNumber(s, n) / 100, e.currentLooseValue = p(e.eventValue, n, r), e;
    if (String(e.currentLooseValue).replace(/[^\d]/g, "").length > ee || x !== s && s && ie && g.findIndex(([c, d]) => {
      const F = s.indexOf(c), z = s.indexOf(d), W = F === 0, k = z === s.length - d.length, q = F + c.length !== b && b !== -1 && s[F + c.length] !== o.decimal, H = z !== E && E !== -1 && s[z - 1] !== o.decimal;
      return c && d ? q || H ? !1 : W && k : c ? q ? !1 : W : d ? H ? !1 : k : !1;
    }) === -1)
      return A(e, n, g, r), e;
    if (x[x.length - 1] === o.decimal && I > 0)
      return e.eventValue = r.parseNumber(s, n), e.currentLooseValue = G, e;
    if (e.currentLooseValue && u && (a + o.decimal + o.group).split("").findIndex((c) => s.split("").filter((d) => d === c).length < l.split("").filter((d) => d === c).length && s.length + 1 === l.length ? !(c === o.decimal && K(l.replace(i, ""), o.decimal) === 0) : !1) > -1)
      return e.eventValue = r.parseNumber(t.prevLooseValue, n), e.currentLooseValue = t.prevLooseValue, e;
    const h = K(x, o.decimal), y = x[x.length - 1] === "0";
    if (v && y && h < R)
      return e.eventValue = r.parseNumber(e.currentLooseValue, n), e.currentLooseValue = p(e.eventValue, n, r), e;
    if (h > 0) {
      const f = s.substring(0, oe);
      if (y && (!f || l.indexOf(f) !== 0)) {
        e.eventValue = r.parseNumber(e.currentLooseValue, n);
        const c = p(e.eventValue, n, r);
        return L(
          e,
          Q(s, c, e.selectionEnd, v, i),
          c,
          g
        ), e.currentLooseValue = c, e;
      }
      if (h > I) {
        const c = s.indexOf(o.decimal), d = s.substring(0, c) + s.substring(c, c + 1 + I) + s.substring(E, String(e.currentLooseValue).length);
        return e.eventValue = r.parseNumber(d, n), e.currentLooseValue = d, L(e, e.selectionStart, d, g), e;
      }
      if (R !== I && h <= I && y)
        return e.eventValue = r.parseNumber(e.currentLooseValue, n), e.currentLooseValue = G, e;
      if (h < R)
        return e.eventValue = r.parseNumber(e.currentLooseValue, n), e.currentLooseValue = p(e.eventValue, n, r), e;
    }
  }
  if (e.eventValue = r.parseNumber(e.currentLooseValue, n), Z && (e.eventValue = e.eventValue / 100), typeof e.eventValue == "number") {
    const V = p(e.eventValue, n, r);
    s.length === 1 ? L(e, B(V, o), V, g) : L(
      e,
      Q(s, V, e.selectionEnd, v, i),
      V,
      g
    ), e.currentLooseValue = V;
  } else
    e.currentLooseValue = p(r.parseNumber(x), n, r);
  return e;
};
export {
  Q as changeBasedSelection,
  Ee as decreaseValue,
  p as formatValue,
  J as fractionLength,
  K as getDecimalCount,
  $ as getFirstNumberIndex,
  be as getFormatPrefixSufix,
  he as getFormatSymbols,
  B as getInitialPosition,
  Ie as getInitialState,
  O as getLastNumberIndex,
  fe as getMaxCursorPosition,
  me as getMinCursorPosition,
  D as getPrefix,
  Ne as getStateOrPropsValue,
  P as getSuffix,
  Ce as increaseValue,
  Le as isDecimalDuplicated,
  pe as isMinusSymbolAdded,
  xe as isMinusSymbolRemoved,
  ge as limitPrecision,
  Ve as rangeSelection,
  re as rangeValue,
  T as reverseString,
  Oe as sanitizeNumber,
  A as setInvalid,
  L as setSelection,
  te as toFixedPrecision
};
