/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as s from "react";
import e from "prop-types";
import { getPageMargin as l } from "../getPageMargin.mjs";
import { savePDF as h } from "../savePDF.mjs";
import { provideSaveGridPDF as g } from "./provideSaveGridPDF.mjs";
import { createPortal as m } from "react-dom";
const i = class i extends s.Component {
  constructor(t) {
    super(t), this.state = {
      show: !1
    }, this.saveGridPDF = g(this.getSavePDF()), this.gridInnerWrapperRef = s.createRef();
  }
  /**
   * @hidden
   */
  componentDidUpdate(t, r) {
    this.state.show && this.state.show !== r.show && this.saveGridPDF(
      this.gridInnerWrapperRef.current,
      Object.assign({}, this.props, { margin: l(this.props) }),
      this.callback
    );
  }
  /**
   * @hidden
   */
  render() {
    return this.state.show && m(
      /* @__PURE__ */ s.createElement(
        "div",
        {
          style: {
            position: "absolute",
            left: "-5000px",
            top: "0px"
          }
        },
        /* @__PURE__ */ s.createElement("div", { ref: this.gridInnerWrapperRef }, this.prepareRawGridForExport(this.data))
      ),
      document.body
    );
  }
  /* eslint-disable max-len */
  /**
   * Saves the content of the Grid as a PDF file.
   *
   * @param data - The data can be different from the currently displayed data in the Grid. Can be used to export all Grid pages.
   * @param callback - The callback that will be executed after the PDF is saved.
   */
  // tslint:enable:max-line-length
  save(t, r) {
    this.grid = this.getGrid(), this.columns = this.getCustomColumns(), this.data = t, this.callback = () => {
      this.setState({ show: !1 }), r && r();
    }, this.setState({ show: !0 });
  }
  getSavePDF() {
    return h;
  }
  getGrid() {
    return s.Children.toArray(this.props.children).find((t) => t && t.type.displayName === "KendoReactGrid");
  }
  getCustomColumns() {
    return s.Children.toArray(this.props.children).filter((t) => t && t.type.displayName === "KendoReactGridColumn");
  }
  prepareRawGridForExport(t) {
    const r = t && { data: t, total: t.length, pageSize: t.length, skip: 0 }, a = { style: Object.assign({}, this.grid.props.style, { width: "1000px" }) }, o = Object.assign({}, r, a);
    if (this.columns && this.columns.length > 0) {
      const p = this.getGridNotColumnChildren(this.grid);
      return s.cloneElement(this.grid, o, this.columns.concat(p));
    } else
      return s.cloneElement(this.grid, o);
  }
  getGridNotColumnChildren(t) {
    return s.Children.toArray(t.props.children).filter((r) => r && r.type && r.type.displayName !== "KendoReactGridColumn");
  }
};
i.propTypes = {
  author: e.string,
  avoidLinks: e.oneOfType([e.bool, e.string]),
  forcePageBreak: e.string,
  keepTogether: e.string,
  creator: e.string,
  date: e.instanceOf(Date),
  imageResolution: e.number,
  fileName: e.string,
  forceProxy: e.bool,
  keywords: e.string,
  landscape: e.bool,
  margin: e.oneOfType([e.string, e.number, e.shape({
    left: e.oneOfType([e.number, e.string]),
    top: e.oneOfType([e.number, e.string]),
    right: e.oneOfType([e.number, e.string]),
    bottom: e.oneOfType([e.number, e.string])
  })]),
  pageTemplate: e.any,
  paperSize: e.any,
  repeatHeaders: e.bool,
  scale: e.number,
  proxyData: e.any,
  proxyURL: e.string,
  proxyTarget: e.string,
  producer: e.string,
  subject: e.string,
  title: e.string
};
let n = i;
export {
  n as GridPDFExport
};
