/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as n from "react";
import c from "prop-types";
import { StepperContext as $ } from "./context/StepperContext.mjs";
import { validatePackage as ee, focusFirstFocusableChild as te, useDir as oe, dispatchEvent as O, Navigation as se, classNames as P, svgIconPropType as A } from "@progress/kendo-react-common";
import { Step as ne } from "./Step.mjs";
import { ProgressBar as re } from "@progress/kendo-react-progressbars";
import { DEFAULT_ANIMATION_DURATION as ie, NO_ANIMATION as le } from "./contants.mjs";
import { packageMetadata as ae } from "../package-metadata.mjs";
import { useLocalization as ce } from "@progress/kendo-react-intl";
import { progBarAriaLabel as T, messages as ue } from "./messages/index.mjs";
const F = n.forwardRef((x, M) => {
  ee(ae);
  const {
    animationDuration: v,
    children: L,
    className: C,
    disabled: f,
    errorIcon: V,
    errorSVGIcon: z,
    item: S,
    items: m,
    linear: g,
    mode: K,
    orientation: I,
    style: N,
    successIcon: G,
    successSVGIcon: H,
    value: u = 0,
    onChange: k,
    onFocus: y
  } = x, U = ce().toLanguageString(T, ue[T]), p = n.useRef(null), w = n.useCallback(
    () => {
      p.current && te(p.current);
    },
    []
  ), E = n.useCallback(
    () => ({
      element: p.current,
      focus: w
    }),
    [w]
  );
  n.useImperativeHandle(M, E);
  const [_, a] = n.useState(u), d = m ? m.length : 0, o = I === "vertical", h = oe(p, x.dir), B = typeof v == "number" ? v : v !== !1 ? ie : le;
  n.useEffect(() => {
    a(u);
  }, [u]);
  const D = n.useCallback(
    (r, i) => {
      const e = i === u - 1, t = i === u, l = i === u + 1;
      u !== i && k && !f && (!g || e || t || l) && (O(
        k,
        r,
        E(),
        { value: i }
      ), a(i));
    },
    [u, g, k, f, a]
  ), j = n.useCallback(
    (r) => {
      let i = r.value, e = r.syntheticEvent;
      D(e, i);
    },
    [D]
  ), q = n.useCallback(
    (r) => {
      y && !f && O(
        y,
        r.syntheticEvent,
        E(),
        void 0
      );
    },
    [y, f]
  ), b = n.useMemo(
    () => {
      const r = h === "rtl", i = m.length - 1;
      return new se({
        root: p,
        selectors: ["ol.k-step-list li.k-step a.k-step-link"],
        tabIndex: 0,
        keyboardEvents: {
          keydown: {
            ArrowLeft: (e, t, l) => {
              l.preventDefault();
              const s = t.elements.indexOf(e);
              !o && !r && s > 0 ? (t.focusPrevious(e), a(s - 1)) : !o && r && s < i && (t.focusNext(e), a(s + 1));
            },
            ArrowRight: (e, t, l) => {
              l.preventDefault();
              const s = t.elements.indexOf(e);
              !o && !r && s < i ? (t.focusNext(e), a(s + 1)) : !o && r && s > 0 && (t.focusPrevious(e), a(s - 1));
            },
            ArrowUp: (e, t, l) => {
              l.preventDefault();
              const s = t.elements.indexOf(e);
              o && !r && s > 0 ? (t.focusPrevious(e), a(s - 1)) : o && r && s > 0 && (t.focusPrevious(e), a(s + 1));
            },
            ArrowDown: (e, t, l) => {
              l.preventDefault();
              const s = t.elements.indexOf(e);
              o && !r && s < i ? (t.focusNext(e), a(s + 1)) : o && r && s < i && (t.focusNext(e), a(s - 1));
            },
            Tab: (e, t, l) => {
              l.preventDefault();
              const s = t.elements.indexOf(e);
              l.shiftKey ? !o && !r && s > 0 ? (t.focusPrevious(e), a(s - 1)) : !o && r && s < i && (t.focusNext(e), a(s + 1)) : !o && !r && s < i ? (t.focusNext(e), a(s + 1)) : !o && r && s > 0 && (t.focusPrevious(e), a(s - 1));
            },
            Home: (e, t, l) => {
              l.preventDefault(), t.focusElement(t.first, e), a(0);
            },
            End: (e, t, l) => {
              l.preventDefault(), t.focusElement(t.last, e), a(i);
            },
            Space: (e, t, l) => {
              l.preventDefault(), e.children[0].click();
            },
            Enter: (e, t, l) => {
              l.preventDefault(), e.children[0].click();
            }
          }
        }
      });
    },
    [h, m.length, o, a]
  );
  n.useEffect(() => (b.initializeRovingTab(u), () => b.removeFocusListener()), []);
  const J = n.useCallback(b.triggerKeyboardEvent.bind(b), []), Q = n.useMemo(
    () => P(
      "k-stepper",
      {
        "k-stepper-linear": g
      },
      C
    ),
    [g, C]
  ), W = n.useMemo(
    () => ({
      display: "grid",
      gridTemplateColumns: o ? void 0 : "repeat(" + d * 2 + ", 1fr)",
      gridTemplateRows: o ? "repeat(" + d + ", 1fr)" : void 0,
      ...N
    }),
    [o, d, N]
  ), X = n.useMemo(
    () => P(
      "k-step-list",
      {
        "k-step-list-horizontal": !o,
        "k-step-list-vertical": o
      }
    ),
    [o]
  ), Y = n.useMemo(
    () => ({
      gridColumnStart: o ? void 0 : 1,
      gridColumnEnd: o ? void 0 : -1,
      gridRowStart: o ? 1 : void 0,
      gridRowEnd: o ? -1 : void 0
    }),
    [o]
  ), Z = n.useMemo(
    () => ({
      gridColumnStart: o ? void 0 : 2,
      gridColumnEnd: o ? void 0 : d * 2,
      gridRowStart: o ? 1 : void 0,
      gridRowEnd: o ? d : void 0,
      top: o ? 17 : void 0
    }),
    [o, d]
  ), R = m && m.map((r, i) => {
    const e = {
      index: i,
      disabled: f || r.disabled,
      focused: i === _,
      current: i === u,
      ...r
    }, t = S || ne;
    return /* @__PURE__ */ n.createElement(t, { key: i, ...e });
  });
  return /* @__PURE__ */ n.createElement(
    $.Provider,
    {
      value: {
        animationDuration: v,
        isVertical: o,
        item: S,
        linear: g,
        mode: K,
        numOfSteps: d,
        value: u,
        successIcon: G,
        successSVGIcon: H,
        errorIcon: V,
        errorSVGIcon: z,
        onChange: j,
        onFocus: q
      }
    },
    /* @__PURE__ */ n.createElement(
      "nav",
      {
        className: Q,
        style: W,
        dir: h,
        role: "navigation",
        ref: p,
        onKeyDown: J
      },
      /* @__PURE__ */ n.createElement(
        "ol",
        {
          className: X,
          style: Y
        },
        R || L
      ),
      /* @__PURE__ */ n.createElement(
        re,
        {
          style: Z,
          labelPlacement: "start",
          animation: { duration: B },
          ariaLabel: U,
          "aria-hidden": !0,
          max: d - 1,
          labelVisible: !1,
          orientation: I,
          reverse: I === "vertical",
          value: u,
          disabled: f,
          tabIndex: -1
        }
      )
    )
  );
});
F.propTypes = {
  animationDuration: c.oneOfType([c.bool, c.number]),
  children: c.any,
  className: c.string,
  dir: c.string,
  disabled: c.bool,
  errorIcon: c.string,
  errorSVGIcon: A,
  item: c.any,
  items: c.any,
  linear: c.bool,
  mode: c.oneOf(["steps", "labels"]),
  orientation: c.oneOf(["horizontal", "vertical"]),
  style: c.object,
  successIcon: c.string,
  successSVGIcon: A,
  value: c.number.isRequired,
  onChange: c.func,
  onFocus: c.func
};
F.displayName = "KendoStepper";
export {
  F as Stepper
};
