/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as t from "react";
import e from "prop-types";
import { validatePackage as W, useDir as X, getter as M, useMouse as Y, getTabIndex as Z, classNames as _, kendoThemeMaps as V } from "@progress/kendo-react-common";
import { selectionReducer as ee } from "./selection-reducer.mjs";
import { focusReducer as te } from "./focus-reducer.mjs";
import { dataReducer as ae } from "./data-reducer.mjs";
import { Chip as D } from "./Chip.mjs";
import { ChipListSelectionContext as ne, ChipListFocusContext as se, ChipListDataContext as ie } from "./chip-list-contexts.mjs";
import { packageMetadata as le } from "../package-metadata.mjs";
const re = (a, i, s) => {
  i.selection === "multiple" ? Array.isArray(a) || (a = a ? [a] : null) : i.selection === "single" && Array.isArray(a) && (a = a ? a.join("") : null);
  const [l, o] = t.useState(a);
  return [l, (c) => {
    const d = ee(i.state || l, { ...c, ...i });
    s && s(d, c.event), i.selection !== "none" && o(d);
  }];
}, oe = (a) => {
  const [i, s] = t.useState(null);
  return [i, (o) => {
    const m = te(o.payload, { ...o, ...a });
    s(m);
  }];
}, ce = (a, i, s) => {
  const [l, o] = t.useState(a);
  return [l, (c) => {
    const d = ae(i.state || l, { ...c, ...i });
    s && s(d, c.event), o(d);
  }];
}, O = t.forwardRef((a, i) => {
  W(le);
  const s = t.useRef(null), l = t.useRef(null), {
    id: o,
    style: m,
    tabIndex: c,
    className: d,
    ariaDescribedBy: E,
    ariaLabelledBy: P,
    ariaLabel: T,
    value: h,
    defaultData: z = r.defaultData,
    chip: g = r.chip,
    disabled: b = r.disabled,
    size: f = r.size,
    defaultValue: N = r.defaultValue,
    selection: x = r.selection,
    valueField: p = r.valueField,
    textField: S = r.textField,
    dir: w = r.dir,
    onChange: y,
    onDataChange: C
  } = a, F = X(l, w), A = t.useMemo(
    () => g || D,
    [g, D]
  );
  t.useImperativeHandle(s, () => ({
    element: l.current,
    props: a
  })), t.useImperativeHandle(i, () => s.current);
  const B = t.useCallback(
    (n, u) => {
      y && s.current && y.call(void 0, {
        value: n,
        target: s.current,
        syntheticEvent: u
      });
    },
    [y]
  ), [k, j] = re(
    h || N,
    {
      selection: x,
      state: h
    },
    B
  ), G = t.useCallback(
    (n, u) => {
      C && s.current && C.call(void 0, {
        value: n,
        target: s.current,
        syntheticEvent: u
      });
    },
    [C]
  ), [L, H] = ce(
    a.data || z,
    {
      state: a.data,
      valueField: p
    },
    G
  ), I = t.useCallback(
    (n, u) => (n.push(u[p]), n),
    [p]
  ), v = t.useMemo(
    () => a.data || L,
    [a.data, L]
  ), K = t.useMemo(
    () => h || k,
    [h, k]
  ), $ = t.useMemo(
    () => v.reduce(I, []),
    [v, I]
  ), R = t.useCallback(
    (n) => M(p)(n),
    [p]
  ), q = t.useCallback(
    (n) => M(S)(n),
    [S]
  ), [J, Q] = oe({ items: $ }), U = Y(a, s);
  return /* @__PURE__ */ t.createElement(ne.Provider, { value: [K, j] }, /* @__PURE__ */ t.createElement(se.Provider, { value: [J, Q] }, /* @__PURE__ */ t.createElement(ie.Provider, { value: [v, H] }, /* @__PURE__ */ t.createElement(
    "div",
    {
      ref: l,
      ...U,
      role: b ? void 0 : "listbox",
      id: o,
      dir: F,
      style: m,
      tabIndex: Z(c, b, void 0),
      className: _(
        "k-chip-list",
        {
          "k-rtl": F === "rtl",
          "k-disabled": b,
          [`k-chip-list-${V.sizeMap[f] || f}`]: f
        },
        d
      ),
      "aria-label": T,
      "aria-labelledby": P,
      "aria-describedby": E,
      "aria-orientation": "horizontal",
      "aria-multiselectable": x === "multiple"
    },
    v.map((n, u) => /* @__PURE__ */ t.createElement(
      A,
      {
        role: "option",
        dataItem: n,
        size: f,
        key: [R(n), u].join("-"),
        text: q(n),
        value: R(n),
        ariaLabel: n.ariaLabel,
        svgIcon: n.svgIcon || void 0
      }
    ))
  ))));
}), de = {
  id: e.string,
  className: e.string,
  tabIndex: e.number,
  data: e.any,
  defaultData: e.arrayOf(e.any),
  onDataChange: e.func,
  value: e.oneOfType([e.any, e.arrayOf(e.any)]),
  defaultValue: e.oneOfType([e.any, e.arrayOf(e.any)]),
  onChange: e.func,
  selection: e.oneOf(["single", "none", "multiple"]),
  textField: e.string,
  valueField: e.string,
  disabled: e.bool,
  dir: e.oneOf(["ltr", "rtl"]),
  ariaLabelledBy: e.string,
  ariaDescribedBy: e.string,
  size: e.oneOf([null, "small", "medium", "large"])
}, r = {
  chip: D,
  size: "medium",
  disabled: !1,
  defaultValue: null,
  defaultData: [],
  dir: "ltr",
  selection: "none",
  textField: "text",
  valueField: "value",
  removable: "removable"
};
O.displayName = "KendoReactChipList";
O.propTypes = de;
export {
  O as ChipList
};
